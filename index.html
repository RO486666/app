<!DOCTYPE html>
<html lang="de">
<head>
<link rel="manifest" href="manifest.json" />
<meta name="theme-color" content="#00aa44" />
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Trade App Layout</title>
  <style>
    body {
      background: #111;
      color: white;
      font-family: sans-serif;
      margin: 0;
      padding: 0;
    }
    .header {
      background: #1c1c1c;
      padding: 10px;
      text-align: center;
      font-size: 18px;
    }
    .session-bar {
      height: 10px;
      background: linear-gradient(to right, #00aaff, #ffaa00, #ff3300);
      margin-top: 5px;
    }
	
    .main {
      padding: 20px;
      padding-bottom: 120px; /* Platz für Positionsleiste */
      text-align: center;
    }
    .big-btn {
      padding: 20px 30px;
      font-size: 22px;
      font-weight: bold;
      border-radius: 15px;
      border: none;
      background-color: #00aa44;
      color: white;
      margin: 20px auto;
      width: 80%;
      max-width: 300px;
    }
    .tab-buttons {
      text-align: center;
      margin-top: 20px;
    }
    .tab-buttons button {
      background: #333;
      color: white;
      padding: 10px 15px;
      border-radius: 5px;
      margin: 5px;
      border: none;
      font-weight: bold;
      cursor: pointer;
    }
    .tab-buttons .active {
      background: #0077cc;
    }
    .stats-box {
      background: #222;
      padding: 15px;
      border-radius: 10px;
      margin-top: 20px;
      text-align: left;
      max-width: 400px;
      margin-left: auto;
      margin-right: auto;
    }
    #resetBtn {
      background: #cc3333;
      color: white;
      padding: 12px;
      border: none;
      border-radius: 8px;
      width: 90%;
      max-width: 400px;
      font-weight: bold;
      margin: 20px auto 30px auto;
      cursor: pointer;
      display: block;
      user-select: none;
      position: relative; /* kein fixed */
      z-index: auto;
    }
    .position-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: #1c1c1c;
      padding: 10px;
      display: flex;
      gap: 10px;
      overflow-x: auto;
      box-sizing: border-box;
      z-index: 10000; /* über anderen Elementen */
	  touch-action: pan-y; /* Erlaubt vertikales Scrollen, verhindert horizontale Interferenzen */
    }
    
    .popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      padding: 20px;
      border-radius: 10px;
      display: none;
      z-index: 1000;
      width: 90%;
      max-width: 300px;
      color: white;
    }
    label {
      cursor: pointer;
      user-select: none;
      margin-right: 15px;
      display: inline-block;
    }
    #pairMultiSelect {
      max-height: 150px;
      overflow-y: auto;
      background: #222;
      padding: 5px;
      border-radius: 6px;
      color: white;
      margin-bottom: 10px;
      text-align: left;
    }
    select, input {
      padding: 8px;
      margin-top: 10px;
      width: 100%;
      border-radius: 5px;
      border: none;
      font-size: 16px;
    }
    .popup button {
      margin-top: 10px;
      padding: 10px;
      width: 100%;
      font-size: 16px;
      cursor: pointer;
    }
    .ticker {
      width: 100%;
      background: #222;
      color: #00ff99;
      padding: 10px;
      text-align: center;
      font-size: 18px;
      font-weight: bold;
      font-family: Arial, sans-serif;
      user-select: none;
    }
    .session-info {
      margin-top: 5px;
      font-size: 14px;
      color: #aaf0aa;
      text-align: center;
      font-style: italic;
      user-select: none;
    }
	
.session-details-box {
  display: none;
  background: #1a1a1a;
  padding: 15px;
  margin: 10px 20px;
  border-radius: 10px;
  font-size: 14px;
  color: #eee;
  text-align: left;
  box-shadow: 0 0 10px rgba(0,0,0,0.4);
}


  .session-details-box {
    font-size: 13px;
    margin: 10px;
    padding: 12px;
    line-height: 1.4;
  }

  .session-header, #sessionText {
    font-size: 16px;
    padding: 12px;
  }
  
  #sessionText {
  user-select: none;
  cursor: pointer;
}
    .progress-container {
      position: relative;
      background: #111;
      height: 24px;
      width: 100%;
      border-top: 1px solid #333;
      border-bottom: 1px solid #333;
      overflow: hidden;
      border-radius: 6px;
      margin-top: 5px;
    }
    .progress-bar {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0%; /* wird per JS gesetzt */
      background: linear-gradient(to right, #00aaff, #ffaa00, #ff3300);
      transition: width 1s linear;
      background-size: 100% 100%;
      background-repeat: no-repeat;
      z-index: 2;
    }
	
	.session-details-box ul {
  padding-left: 20px;
  margin-top: 8px;
  margin-bottom: 8px;
  list-style-type: disc;
}

.session-details-box li {
  margin-bottom: 4px;
}

.tool-button {
  background-color: #333;
  color: white;
  border: none;
  padding: 10px 20px;
  margin: 5px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
}
.tool-button:hover {
  background-color: #444;
}
.tool-box {
  background: #222;
  padding: 20px;
  border-radius: 10px;
  color: white;
  max-width: 400px;
  margin: auto;
  box-shadow: 0 0 10px rgba(255,255,255,0.1);
}

.tool-box input,
.tool-box button {
  width: 100%;
  margin-bottom: 10px;
  padding: 8px;
  border: none;
  border-radius: 5px;
  font-size: 14px;
}

.tool-box button {
  background: #007bff;
  color: white;
  font-weight: bold;
  cursor: pointer;
}

.crypto-animate {
  font-weight: bold;
  font-size: 18px;
  color: #00ffcc;
  text-shadow: 0 0 5px #00ffcc, 0 0 10px #00ffcc, 0 0 20px #00ffcc;
  animation: glowPulse 2s infinite alternate;
  display: inline-flex;
  align-items: center;
  gap: 5px;
}

.crypto-animate .coin {
  display: inline-block;
  animation: spinCoin 1.5s linear infinite;
  font-size: 22px;
}

@keyframes spinCoin {
  0%   { transform: rotateY(0deg); }
  100% { transform: rotateY(360deg); }
}

@keyframes glowPulse {
  0% {
    text-shadow: 0 0 5px #00ffcc, 0 0 10px #00ffcc;
  }
  100% {
    text-shadow: 0 0 15px #00ffcc, 0 0 30px #00ffcc;
  }
}

.star-rating {
  unicode-bidi: bidi-override;
  direction: rtl;
  display: inline-flex;
}
.star-rating span {
  font-size: 24px;
  cursor: pointer;
  color: #777;
}
.star-rating span.selected {
  color: gold;
}


.journal-screenshot {
  max-width: 160px;
  max-height: 120px;
  width: auto;
  height: auto;
  object-fit: contain;
  border-radius: 6px;
  margin-top: 5px;
  display: block;
  cursor: pointer;
  transition: transform 0.2s ease;
}

.tax-button {
  background: #cc3333;
  color: white;
  padding: 12px;
  border: none;
  border-radius: 8px;
  width: 100%;
  font-weight: bold;
  font-size: 16px;
  margin-top: 10px;
  cursor: pointer;
  box-shadow: 0 0 12

.tax-button:hover {
  background: #ff4444;
  box-shadow: 0 0 20px #ff4444;
}



  </style>
<style>
  #tickerContent {
    display: inline-block;
    white-space: nowrap;
    position: relative;
    left: 100%; /* Start rechts außerhalb */
  }
  .ticker {
    overflow: hidden;
    white-space: nowrap;
    width: 100%;
    background: #111;
    color: #00ff99;
    font-size: 14px;
    padding: 6px 10px;
    border-top: 1px solid #333;
    border-bottom: 1px solid #333;
    position: relative;
  }
</style>

<div class="ticker">
  <div id="tickerContent"></div>
</div>

<script>
  const ticker = document.getElementById("tickerContent");
  const focusPairsByDay = {
    0: [ "BTC/USD", "ETH/USD", "SOL/USD", "XRP/USD", "LTC/USD", "ADA/USD", "BCH/USD", "XAU/USD", "XAG/USD", "XPT/USD", "XPD/USD", "COPPER/USD", "ALUMINIUM/USD", "US30", "NAS100", "SPX500", "GER40", "UK100" ],
    1: [ "EUR/USD", "GBP/USD", "AUD/USD", "NZD/USD", "USD/CHF", "USD/CAD", "EUR/JPY", "GBP/JPY", "CHF/JPY", "AUD/JPY", "CAD/JPY", "EUR/GBP", "XAU/USD", "XAG/USD", "BTC/USD", "ETH/USD" ],
    2: [ "USD/JPY", "EUR/JPY", "GBP/JPY", "CHF/JPY", "AUD/JPY", "NZD/JPY", "CAD/JPY", "BTC/USD", "ETH/USD", "SOL/USD", "XRP/USD" ],
    3: [ "US30", "NAS100", "SPX500", "GER40", "UK100", "EUR/GBP", "EUR/AUD", "EUR/CAD", "GBP/AUD", "GBP/CAD", "AUD/CAD" ],
    4: [ "GBP/USD", "GBP/JPY", "GBP/AUD", "GBP/CAD", "XAU/USD", "XAG/USD", "WTI/USD", "BRENT/USD", "NATGAS/USD" ],
    5: [ "XAU/USD", "XAG/USD", "BTC/USD", "ETH/USD", "US30", "NAS100", "SPX500" ],
    6: [ "ETH/USD", "SOL/USD", "XRP/USD", "BTC/USD", "LTC/USD", "ADA/USD" ]
  };

  // Zeiten in ms
  const enterDuration = 5000; // 5 Sekunden reinfahren
  const stayDuration = 40000; // 40 Sekunden Pause
  const exitDuration = 5000;  // 5 Sekunden rausfahren

  function animateTicker() {
    const now = new Date();
    const day = now.getDay();
    const pairs = focusPairsByDay[day] || [];
    ticker.textContent = pairs.join("  |  ") + "  |  ";

    // 1. Starte rechts außerhalb (left: 100%)
    ticker.style.transition = "none";
    ticker.style.left = "100%";

    // 2. Nach kurzem Timeout reinfahren (left: 0%) mit Transition
    setTimeout(() => {
      ticker.style.transition = `left ${enterDuration}ms linear`;
      ticker.style.left = "0%";
    }, 50);

    // 3. Nach reinfahren die Transition ausschalten für Pause (damit bleibt es an 0%)
    setTimeout(() => {
      ticker.style.transition = "none";
      ticker.style.left = "0%";
    }, enterDuration + 60); // kleine Verzögerung nach Ende reinfahren

    // 4. Nach Pause rausfahren
    setTimeout(() => {
      // Jetzt wieder Transition an, um rauszufahren
      // WICHTIG: Transition nur aktivieren, wenn left anders als -100% ist (sonst springt er evtl)
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          ticker.style.transition = `left ${exitDuration}ms linear`;
          ticker.style.left = "-100%";
        });
      });
    }, enterDuration + stayDuration + 60);

    // 5. Loop restart
    setTimeout(() => {
      animateTicker();
    }, enterDuration + stayDuration + exitDuration + 150);
  }

  document.addEventListener("DOMContentLoaded", animateTicker);
</script>




</script>

</head>
<body>







<div class="ticker" id="sessionText">Session-Zeit: 00:00</div>

<div class="session-info" id="sessionInfo">Tipps und Infos zur Session erscheinen hier...</div>

<div class="progress-container">
  <div class="progress-bar" id="progressBar"></div>
</div>

<div id="daySummary" class="ticker" style="background:#333; color:#ffcc00; font-size:16px; cursor:pointer;">
  🗓️ Lade Tagesinfo...
</div>

<div id="dayDetails" style="
  display: none;
  background: #1c1c1c;
  color: white;
  margin: 10px 15px;
  padding: 10px;
  border-radius: 10px;
  font-size: 14px;
  line-height: 1.6;
  box-shadow: 0 0 10px rgba(0,0,0,0.5);
  text-align: left;
  user-select: none;
">
</div>

<div id="sessionProgressDisplay"
     style="text-align:center;
            font-size: 16px;
            font-weight: bold;
            margin-top: 8px;
            color: #00ff99;
            background: #111;
            padding: 6px;
            border-radius: 8px;">
</div>

<div class="session-details-box" id="sessionDetailsBox"></div>
<div class="alert-below-header" id="alertBox"></div>


<!-- Tab-Buttons -->
<div class="tab-buttons" style="margin-top: 20px;">
  <button class="btn" id="btn-calc-pos" onclick="switchCalcTab('pos')">📐 Position Size</button>
  <button class="btn" id="btn-calc-lot" onclick="switchCalcTab('lot')">🧮 Lot-Rechner</button>
  <button class="btn" id="btn-calc-breakeven" onclick="switchCalcTab('breakeven')">🧠 Break-even</button>
  <button class="btn" id="btn-calc-taxpro" onclick="switchCalcTab('taxpro')" style="
    background: #cc3333;
    color: white;
    padding: 10px 15px;
    border-radius: 5px;
    margin: 5px;
    border: none;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 0 12px #cc3333;
    transition: all 0.2s ease-in-out;
  ">
    📄 Steuer / Netto-Planer
  </button>
</div>



<div id="calc-taxpro" class="calc-box" style="margin-top: 15px; display: none;">
  <div class="stats-box">
    <!-- 🔁 Umschaltbare Ansicht -->
    <div id="steuerMode">
      <label for="gewinnBetrag">📈 Gesamtgewinn (€):</label>
      <input type="number" id="gewinnBetrag" placeholder="z. B. 17200" />

      <label for="einkommenSteuer">💸 Einkommensteuer-Satz (%):</label>
      <input type="number" id="einkommenSteuer" placeholder="z. B. 25" value="25" step="0.1" />

      <label><input type="checkbox" id="kirchensteuer" /> ✝️ Kirchensteuer (9 %)</label><br>
      <label><input type="checkbox" id="soliZuschlag" /> 💣 Solidaritätszuschlag (5.5 %)</label><br>
      <label><input type="checkbox" id="reserveZehn" /> 💥 +10 % Reserve</label><br>

      <button onclick="berechneSteuern()" class="tax-button">📊 Steuer berechnen</button>
      <div id="steuerAusgabe"></div>
    </div>

    <div id="nettoMode" style="display:none">
      <label for="nettoBrutto">📈 Brutto-Gewinn (€):</label>
      <input type="number" id="nettoBrutto" placeholder="z. B. 10000" />

      <label for="nettoSteuer">💸 Steuerlast (€):</label>
      <input type="number" id="nettoSteuer" placeholder="z. B. 3500" />

      <label for="nettoEntnommen">🏦 Tatsächlich entnommen (€):</label>
      <input type="number" id="nettoEntnommen" placeholder="z. B. 8000" />

      <button onclick="berechneNettoPlan()" class="tax-button">💸 Netto berechnen</button>
      <div id="nettoAusgabe"></div>
    </div>

    <!-- 🧠 Umschalter -->
    <button onclick="switchPlanMode()" id="planToggleBtn" style="
      margin-top: 15px;
      background: #444;
      color: white;
      padding: 10px;
      font-size: 14px;
      border: none;
      border-radius: 6px;
      width: 100%;
      cursor: pointer;
      font-weight: bold;
    ">
    🔁 Zu Netto-Planer wechseln
    </button>
  </div>
</div>








<div id="calc-pos" class="calc-box" style="margin-top: 15px; display:none;">

  <div class="stats-box">
    <label for="accountSize">📦 Kontogröße (€):</label>
    <input type="number" id="accountSize" placeholder="z. B. 1000" />

    <label for="riskPercent">⚠️ Risiko in %:</label>
    <input type="number" id="riskPercent" placeholder="z. B. 1" step="0.1" />

    <label for="stopLossPips">🛑 Stop-Loss (in Pips):</label>
    <input type="number" id="stopLossPips" placeholder="z. B. 20" />

<label for="symbolSelector">💱 Trading-Paar:</label>
<select id="symbolSelector">
  <optgroup label="🌍 Forex Standard">
    <option value="AUD/USD">AUD/USD</option>
    <option value="EUR/USD">EUR/USD</option>
    <option value="GBP/USD">GBP/USD</option>
    <option value="NZD/USD">NZD/USD</option>
    <option value="USD/CHF">USD/CHF</option>
    <option value="USD/CAD">USD/CAD</option>
  </optgroup>

  <optgroup label="💴 Forex Yen-Paare">
    <option value="USD/JPY">USD/JPY</option>
    <option value="EUR/JPY">EUR/JPY</option>
    <option value="GBP/JPY">GBP/JPY</option>
    <option value="CHF/JPY">CHF/JPY</option>
    <option value="AUD/JPY">AUD/JPY</option>
    <option value="NZD/JPY">NZD/JPY</option>
    <option value="CAD/JPY">CAD/JPY</option>
  </optgroup>

  <optgroup label="🔁 Cross-Paare">
    <option value="EUR/GBP">EUR/GBP</option>
    <option value="EUR/AUD">EUR/AUD</option>
    <option value="EUR/CAD">EUR/CAD</option>
    <option value="GBP/AUD">GBP/AUD</option>
    <option value="GBP/CAD">GBP/CAD</option>
    <option value="AUD/CAD">AUD/CAD</option>
  </optgroup>

  <optgroup label="🥇 Metalle">
    <option value="XAU/USD">XAU/USD</option>
    <option value="XAG/USD">XAG/USD</option>
  </optgroup>

  <optgroup label="🪙 Krypto">
    <option value="BTC/USD">BTC/USD</option>
    <option value="ETH/USD">ETH/USD</option>
  </optgroup>

  <optgroup label="📊 Indizes">
    <option value="US30">US30</option>
    <option value="NAS100">NAS100</option>
    <option value="SPX500">SPX500</option>
    <option value="GER40">GER40</option>
    <option value="UK100">UK100</option>
  </optgroup>
  
</select>

<label for="leverage">⚙️ Hebel:</label>
<input type="number" id="leverage" value="500" min="1" placeholder="z. B. 500" />




    <button onclick="calculatePositionSize()">📐 Berechnen</button>
    <p id="positionSizeResult" style="font-weight: bold; font-size: 18px; margin-top: 10px;"></p>
  </div>

  <div style="text-align:right; margin-bottom: 5px;">
    <span onclick="toggleInfoBox()" 
          style="cursor:pointer; background:#444; border-radius:50%; padding:3px 8px; font-weight:bold; color:#0ff;"
          title="Erklärung anzeigen">i</span>
  </div>
  <div id="posInfoBox" style="display:none; background:#222; padding:12px; border-radius:8px; margin-top:10px; color:#ccc; font-size:14px; text-align:left;">
    <strong>ℹ️ Was macht dieser Rechner?</strong><br><br>
    Der Positionsgrößen-Rechner hilft dir zu ermitteln, wie viele Lots du in einem Trade einsetzen darfst, ohne mehr als einen bestimmten Prozentsatz deines Kontos zu riskieren. Die Berechnung basiert auf vier Angaben:
    <ul style="margin-top:10px; margin-bottom:10px;">
      <li><strong>📦 Kontogröße:</strong> Dein aktuelles Guthaben in Euro.</li>
      <li><strong>⚠️ Risiko in %:</strong> Wie viel Prozent deines Kontos du maximal pro Trade verlieren willst (z. B. 1%).</li>
      <li><strong>🛑 Stop-Loss (Pips):</strong> Die Distanz zwischen Einstieg und Stop-Loss in Pips.</li>
      <li><strong>💡 Pip-Wert pro Lot:</strong> Wie viel ein Pip pro Standard-Lot wert ist (z. B. 10 € bei EUR/USD).</li>
    </ul>
    <strong>📐 Formel:</strong><br>
    <code style="color:#0ff;">Positionsgröße = (Kontogröße × Risiko%) / (Stop-Loss × Pip-Wert)</code><br><br>
    <strong>🔍 Beispiel:</strong><br>
    Kontogröße: 1000 €<br>
    Risiko: 2%<br>
    Stop-Loss: 20 Pips<br>
    Pip-Wert: 10 €/Lot<br><br>
    <strong>→</strong> Du riskierst 20 € (1000 × 0,02).<br>
    <strong>→</strong> Bei 20 Pips wären das 1 €/Pip erlaubt (20 € / 20 Pips).<br>
    <strong>→</strong> Der Pip-Wert ist 10 €/Lot ⇒ <strong>Erlaubte Lotgröße: 0.10</strong><br><br>
    <em style="color:#aaa;">Hinweis: Bei Indizes oder Gold kann der Pip-Wert unterschiedlich sein!</em>
  </div>
</div>


  <div style="text-align:right; margin-bottom: 5px;">
    <span onclick="toggleRiskInfo()" 
          style="cursor:pointer; background:#444; border-radius:50%; padding:3px 8px; font-weight:bold; color:#0ff;"
          title="Erklärung anzeigen">i</span>
  </div>

  <div id="riskInfoBox" style="display:none; background:#222; padding:12px; border-radius:8px; margin-top:10px; color:#ccc; font-size:14px; text-align:left;">
    <strong>ℹ️ Was macht dieser Rechner?</strong><br><br>
    Der Risiko-%-Rechner zeigt dir, wie viel Geld du bei einem Trade riskierst und wie viel Prozent deines Kontos das ausmacht. Er basiert auf:

    <ul style="margin-top:10px; margin-bottom:10px;">
      <li><strong>📦 Kontogröße:</strong> Dein Kontoguthaben in Euro</li>
      <li><strong>🧮 Lotgröße:</strong> Wie groß dein Trade ist (z. B. 0.1 = Mini-Lot)</li>
      <li><strong>🛑 Stop-Loss (Pips):</strong> Wie weit der SL vom Einstieg entfernt ist</li>
      <li><strong>💡 Pip-Wert:</strong> Wie viel 1 Pip pro Lot kostet (z. B. 10 €)</li>
    </ul>

    <strong>📐 Formel:</strong><br>
    <code style="color:#0ff;">Risiko (€) = Lotgröße × SL × Pip-Wert<br>
    Risiko-% = Risiko / Kontogröße × 100</code><br><br>

    <strong>🔍 Beispiel:</strong><br>
    Konto: 1000 €<br>
    Lot: 0.2<br>
    SL: 30 Pips<br>
    Pip-Wert: 10 €<br>
    → Risiko = 0.2 × 30 × 10 = 60 €<br>
    → Risiko-% = 60 / 1000 = <strong>6 %</strong><br><br>

    <em style="color:#aaa;">Achte darauf, dass dein Risiko unter 2 % bleibt, um langfristig zu überleben.</em>
  </div>
</div>



<div id="calc-lot" class="calc-box" style="display:none; margin-top: 15px;">
  <div class="stats-box">
    <label for="lotFixedRisk">💰 Risiko in Euro:</label>
    <input type="number" id="lotFixedRisk" placeholder="z. B. 50" />

    <label for="lotSL">🛑 Stop-Loss (in Pips):</label>
    <input type="number" id="lotSL" placeholder="z. B. 20" />

    <label for="lotPipValue">💡 Pip-Wert pro Lot (€):</label>
    <input type="number" id="lotPipValue" placeholder="z. B. 10" value="10" />

    <button onclick="calculateLotFromFixed()">🧮 Lotgröße berechnen</button>

    <p id="lotResult" style="font-weight: bold; font-size: 18px; margin-top: 10px;"></p>
  </div>

  <div style="text-align:right; margin-bottom: 5px;">
    <span onclick="toggleLotInfo()" 
          style="cursor:pointer; background:#444; border-radius:50%; padding:3px 8px; font-weight:bold; color:#0ff;"
          title="Erklärung anzeigen">i</span>
  </div>

  <div id="lotInfoBox" style="display:none; background:#222; padding:12px; border-radius:8px; margin-top:10px; color:#ccc; font-size:14px; text-align:left;">
    <strong>ℹ️ Was macht dieser Rechner?</strong><br><br>
    Du gibst an, wie viel Euro du maximal verlieren willst – der Rechner sagt dir, welche Lotgröße das erlaubt.<br><br>

    <strong>Beispiel:</strong><br>
    Risiko: 100 €<br>
    SL: 25 Pips<br>
    Pip-Wert: 10 €/Lot<br>
    → <code style="color:#0ff;">Lots = 100 / (25 × 10) = 0.40</code>
  </div>
</div>

<div id="calc-breakeven" class="calc-box" style="display:none; margin-top: 15px;">
  <div class="stats-box">
    <label for="entryPrice">🎯 Einstiegspreis:</label>
    <input type="number" id="entryPrice" placeholder="z. B. 1.12345" step="0.00001" />

    <label for="spreadPips">📏 Spread (Pips):</label>
    <input type="number" id="spreadPips" placeholder="z. B. 1.5" step="0.1" />

    <label for="fees">💸 Gebühren (€):</label>
    <input type="number" id="fees" placeholder="z. B. 2.00" step="0.01" />

    <label for="beLotSize">🧮 Lotgröße:</label>
    <input type="number" id="beLotSize" placeholder="z. B. 0.1" step="0.01" />

    <label for="bePipValue">💡 Pip-Wert pro Lot (€):</label>
    <input type="number" id="bePipValue" placeholder="z. B. 10" value="10" />

    <button onclick="calculateBreakeven()">🧠 Break-even berechnen</button>

    <p id="breakevenResult" style="font-weight: bold; font-size: 18px; margin-top: 10px;"></p>
  </div>

  <div style="text-align:right; margin-bottom: 5px;">
    <span onclick="toggleBreakevenInfo()" 
          style="cursor:pointer; background:#444; border-radius:50%; padding:3px 8px; font-weight:bold; color:#0ff;"
          title="Erklärung anzeigen">i</span>
  </div>

  <div id="breakevenInfoBox" style="display:none; background:#222; padding:12px; border-radius:8px; margin-top:10px; color:#ccc; font-size:14px; text-align:left;">
    <strong>ℹ️ Was macht dieser Rechner?</strong><br><br>
    Der Break-even-Rechner zeigt dir den Preis, bei dem dein Trade exakt auf Null läuft – also weder Gewinn noch Verlust.<br><br>

    Dabei berücksichtigt werden:
    <ul style="margin-top:10px; margin-bottom:10px;">
      <li><strong>🎯 Einstiegspreis:</strong> Der Preis, zu dem du den Trade geöffnet hast.</li>
      <li><strong>📏 Spread:</strong> Unterschied zwischen Bid und Ask in Pips.</li>
      <li><strong>💸 Gebühren:</strong> z. B. Kommissionen des Brokers.</li>
      <li><strong>🧮 Lotgröße:</strong> Deine aktuelle Positionsgröße.</li>
      <li><strong>💡 Pip-Wert:</strong> Wert eines Pips pro Lot (z. B. 10 € bei Forex).</li>
    </ul>

    <strong>📐 Formel:</strong><br>
    <code style="color:#0ff;">Break-even = Einstiegspreis ± (Spread + Gebühren ÷ (Lotgröße × Pip-Wert))</code><br><br>

    <em style="color:#aaa;">Ob du + oder – rechnest, hängt davon ab, ob du Long oder Short bist. Dieser Rechner geht vom LONG-Trade aus.</em>
  </div>
</div>

<div id="calc-leverage" class="calc-box" style="display:none; margin-top: 15px;">
  <div class="stats-box">
    <label for="leverageMode">Berechnungsmodus:</label>
    <select id="leverageMode" onchange="toggleLeverageMode()">
      <option value="capital">🔁 Hebel ➜ Kapital berechnen</option>
      <option value="lotcheck">📊 Hebel + Kapital ➜ Lotcheck</option>
    </select>

    <!-- MODUS 1: Hebel ➜ Kapital -->
    <div id="capitalMode">
      <label for="leverageInput1">📦 Kapital (in €):</label>
      <input type="number" id="leverageInput1" placeholder="z. B. 500" />

      <label for="leverageInput2">💼 Lotgröße:</label>
      <input type="number" id="leverageInput2" placeholder="z. B. 1.0" step="0.01" />

      <label for="leverageInput3">📈 Hebel:</label>
      <input type="number" id="leverageInput3" placeholder="z. B. 10" step="1" />
    </div>

    <!-- MODUS 2: Hebel + Kapital ➜ Lotcheck -->
    <div id="lotCheckMode" style="display:none">
  <label for="lotCapital">📦 Kapital (in €):</label>
  <input type="number" id="lotCapital" placeholder="z. B. 250" />

  <label for="lotLeverage">💡 Hebel (z. B. 500):</label>
  <input type="number" id="lotLeverage" placeholder="z. B. 500" />

  <label for="lotPair">📊 Währungspaar:</label>
<select id="lotPair">
  <optgroup label="🔁 Forex">
    <option value="EUR/USD">EUR/USD</option>
    <option value="GBP/USD">GBP/USD</option>
    <option value="AUD/USD">AUD/USD</option>
    <option value="NZD/USD">NZD/USD</option>
    <option value="USD/CAD">USD/CAD</option>
    <option value="USD/CHF">USD/CHF</option>
    <option value="USD/JPY">USD/JPY</option>
    <option value="EUR/JPY">EUR/JPY</option>
    <option value="GBP/JPY">GBP/JPY</option>
    <option value="CHF/JPY">CHF/JPY</option>
    <option value="AUD/JPY">AUD/JPY</option>
    <option value="CAD/JPY">CAD/JPY</option>
    <option value="EUR/GBP">EUR/GBP</option>
    <option value="EUR/AUD">EUR/AUD</option>
    <option value="EUR/CAD">EUR/CAD</option>
    <option value="GBP/AUD">GBP/AUD</option>
    <option value="GBP/CAD">GBP/CAD</option>
  </optgroup>

  <optgroup label="🥇 Rohstoffe">
    <option value="XAU/USD">XAU/USD (Gold)</option>
    <option value="XAG/USD">XAG/USD (Silber)</option>
  </optgroup>

  <optgroup label="💹 Indizes">
    <option value="US30">US30 (Dow Jones)</option>
    <option value="NAS100">NAS100 (Nasdaq)</option>
    <option value="SPX500">SPX500 (S&P 500)</option>
    <option value="GER40">GER40 (DAX)</option>
    <option value="UK100">UK100 (FTSE)</option>
  </optgroup>

  <optgroup label="₿ Krypto">
    <option value="BTC/USD">BTC/USD</option>
    <option value="ETH/USD">ETH/USD</option>
  </optgroup>
</select>

</div>

    <button onclick="calculateLeverage()">🔧 Berechnen</button>
    <p id="leverageResult" style="font-weight: bold; font-size: 18px; margin-top: 10px;"></p>
  </div>
</div>



  <!-- 📆 Kalender -->
<div id="journalCalendarBox" class="stats-box" style="margin-top: 20px;">
  <div style="display:flex; justify-content:space-between; align-items:center;">
    <button onclick="changeMonth(-1)">⬅️</button>
    <h3 id="calendarTitle">🗓️ Journal-Kalender</h3>
    <button onclick="changeMonth(1)">➡️</button>
  </div>

  <canvas id="calendarEquityChart" height="150" style="margin:10px auto 5px auto; display:block;"></canvas>

  <div id="calendarEquityStats" style="color: #ccc; margin-top: 5px;"></div>
  <div id="calendarContainer" style="margin-top: 10px;"></div>
  <div id="calendarStats" style="margin-top: 5px; color: #ccc;"></div>
  <div id="journalEntryList" style="margin-top: 0;"></div>
</div>

<!-- 📘 Journal-Eingabe -->
<div id="calc-journal" class="calc-box" style="display:none; margin-top: 10px;">
  <div class="stats-box" style="display: flex; flex-direction: column; gap: 14px; max-width: 500px; margin: auto; padding: 20px; border-radius: 12px; background: #1a1a1a; color: #eee;">

    <label>🧭 Strategie-Modus:</label>
    <select id="tradingMode" onchange="updateBiasOptions()" class="input" style="width: 100%;">

      <option value="day">Daytrading</option>
      <option value="swing">Swing-Trading</option>
    </select>

    <label>📆 Datum:</label>
    <input type="date" id="journalManualDate" class="input" style="width: 100%;" />

    <label>💱 Symbol:</label>
    <input type="text" id="journalSymbol" class="input" placeholder="z. B. EUR/USD" oninput="suggestSymbol()" autocomplete="off" style="width: 100%;" />
    <div id="symbolSuggestions" style="background:#222; color:white; padding:5px; display:none; border-radius:6px;"></div>

<!-- Einstieg + Ausstieg + Richtung -->
<div style="display: flex; gap: 10px; flex-wrap: wrap;">
  <div style="flex: 1; min-width: 130px;">
    <label>🎯 Einstieg:</label>
    <input type="number" id="journalEntry" class="input" style="width: 100%;" onchange="autoSuggestExit()" />
  </div>
  <div style="flex: 1; min-width: 130px;">
    <label>🏁 Ausstieg:</label>
    <input type="number" id="journalExit" class="input" style="width: 100%;" onchange="userChangedExit = true;" />
  </div>
  <div style="flex: 1; min-width: 130px;">
    <label>Richtung:</label>
    <select id="journalDirection" class="input" onchange="autoSuggestExit()">
      <option value="long">📈 Long</option>
      <option value="short">📉 Short</option>
    </select>
  </div>
</div>

  <div style="display: flex; flex-direction: column; gap: 10px;">
<div>
  <label>📦 Lotgröße:</label>
  <select id="journalLots" class="input" style="width: 100%; background-color: white; color: black;">
    <option value="">– Bitte wählen –</option>
    <option value="0.01">0.01</option>
    <option value="0.02">0.02</option>
    <option value="0.03">0.03</option>
    <option value="0.05">0.05</option>
    <option value="0.10">0.10</option>
    <option value="0.25">0.25</option>
    <option value="0.50">0.50</option>
    <option value="1.00">1.00</option>
    <option value="2.00">2.00</option>
    <option value="3.00">3.00</option>
    <option value="5.00">5.00</option>
    <option value="10.00">10.00</option>
    <option value="25.00">25.00</option>
    <option value="50.00">50.00</option>
    <option value="100.00">100.00</option>
  </select>
</div>


  <div>
    <label>📊 PnL (€):</label>
<input type="text"
       id="journalPnL"
       class="input"
       placeholder="z. B. -50.00"
       inputmode="numeric"
       pattern="^-?[0-9]+([.,][0-9]{1,2})?$"
       style="width: 100%; background-color: white; color: black;" />


  </div>
</div>


  <div class="emotion-block">
  <label>😐 Fokus <strong>vor</strong> dem Trade:</label>
  <div id="starsBefore" class="star-rating"></div>
  <input type="hidden" id="emotionBefore" value="5" />
</div>

<div class="emotion-block">
  <label>😤 Emotion <strong>nach</strong> dem Trade:</label>
  <div id="starsAfter" class="star-rating"></div>
  <input type="hidden" id="emotionAfter" value="5" />
</div>


    <label>🧠 Setup:</label>
    <select id="journalSetup" class="input" style="width: 100%;">
      <option value="">– Setup wählen –</option>
      <option value="Breakout">Breakout</option>
      <option value="Rejection">Rejection</option>
      <option value="Liquidity Grab">Liquidity Grab</option>
      <option value="News Spike">News Spike</option>
      <option value="Orderblock Reentry">Orderblock Reentry</option>
    </select>

<!-- 🧱 Setup-Box Start -->
<div id="setupBoxWrapper"
  style="margin-top: 10px; border-radius: 12px; padding: 16px;
         background: linear-gradient(135deg, #3d1e1e, #6b2f2f);
         border: 2px solid #aa3333;
         color: #eee;
         box-shadow: 0 0 8px rgba(255, 50, 50, 0.25);
         transition: all 0.3s ease;">

  <label style="font-weight: bold; font-size: 16px; display: block; margin-bottom: 10px; color: #f0f0f0; text-shadow: 1px 1px 2px black;">
    ✅ Setup-Check
  </label>

  <label style="margin-top: 5px; color: #f0f0f0; text-shadow: 1px 1px 2px black;">🧭 Multi-Timeframe Bias:</label>
  <div id="biasTimeframes" style="display: flex; flex-wrap: wrap; gap: 10px; font-size: 14px; color: #eeeeee; text-shadow: 1px 1px 2px black;">
    <label><input type="checkbox" value="15M" onchange="updateSetupScoreDisplay()" /> 15M</label>
    <label><input type="checkbox" value="30M" onchange="updateSetupScoreDisplay()" /> 30M</label>
    <label><input type="checkbox" value="1H" onchange="updateSetupScoreDisplay()" /> 1H</label>
    <label><input type="checkbox" value="4H" onchange="updateSetupScoreDisplay()" /> 4H</label>
    <label><input type="checkbox" value="D1" onchange="updateSetupScoreDisplay()" /> D1</label>
    <label><input type="checkbox" value="W1" onchange="updateSetupScoreDisplay()" /> W1</label>
  </div>

  <div id="ruleChecklist" style="display: flex; flex-direction: column; gap: 10px; font-size: 14px; margin-top:10px; color: #eeeeee; text-shadow: 1px 1px 2px black;">
    <label><input type="checkbox" id="ruleAOI" onchange="updateSetupScoreDisplay()" />
      🧱 AOI / POI reagiert sichtbar
    </label>
    <small style="margin-left: 20px; color:#dddddd; text-shadow: 1px 1px 1px black;">
      ▶ Preis reagiert klar in AOI&POI (z. B. W, D1)
    </small>

    <label><input type="checkbox" id="ruleEntry" onchange="updateSetupScoreDisplay()" />
      🎯 Entry-Trigger bestätigt
    </label>
    <small style="margin-left: 20px; color:#dddddd; text-shadow: 1px 1px 1px black;">
      ▶ Rejection, Equal High/Low Raid, Shift
    </small>

    <label><input type="checkbox" id="ruleEntryPattern" onchange="updateSetupScoreDisplay()" />
      🧠 Einstiegsmuster sichtbar
    </label>
    <small style="margin-left: 20px; color:#dddddd; text-shadow: 1px 1px 1px black;">
      ▶ z. B. Inside Bar, Morning Star, Pinbar, Engulfing, Quasimodo
    </small>

    <label><input type="checkbox" id="rulePsych" onchange="updateSetupScoreDisplay()" />
      💡 Psychologisches Level
    </label>
    <small style="margin-left: 20px; color:#dddddd; text-shadow: 1px 1px 1px black;">
      ▶ 00/50-Level, Vorwochen-Hoch/Tief, runde Zahlen (z. B. 1900, 1950)
    </small>

    <label><input type="checkbox" id="ruleSession" onchange="updateSetupScoreDisplay()" />
      🕒 Richtiges Zeitfenster
    </label>
    <small style="margin-left: 20px; color:#dddddd; text-shadow: 1px 1px 1px black;">
      ▶ Killzones: London (08:00–11:00), New York (14:30–17:00), Asia (02:00–04:00)
    </small>

    <label><input type="checkbox" id="ruleRR" onchange="updateSetupScoreDisplay()" />
      📏 Minimum 1:2.5 RR
    </label>
    <small style="margin-left: 20px; color:#dddddd; text-shadow: 1px 1px 1px black;">
      ▶ Laut Struktur realistisch erreichbares Ziel: ≥ 2,5x SL-Distanz
    </small>

    <label><input type="checkbox" id="ruleLTFShift" onchange="updateSetupScoreDisplay()" />
      🔁 LTF Strukturwechsel (Shift)
    </label>
    <small style="margin-left: 20px; color:#dddddd; text-shadow: 1px 1px 1px black;">
      ▶ MSS auf 15M - 2H → z. B. HL → HH → LL
    </small>

    <div id="setupScoreDisplay" style="margin-top: 12px; font-size: 14px; font-weight: bold; color: #f0f0f0; text-shadow: 1px 1px 2px black;">
      📊 Setup-Score: <strong>0%</strong> – ❌ Nicht gültig
    </div>
  </div> <!-- ✅ Ende der Regel-Checkliste-Box -->

</div> <!-- ✅ Ende setupBoxWrapper -->

<!-- 🔻 Jetzt alles außerhalb der Box -->
<div style="margin-top: 20px; font-size: 14px; color: #eeeeee; text-shadow: 1px 1px 2px black;">

  <label>📝 Kommentar <strong>vor dem Trade</strong>:</label>
  <textarea id="journalNotesBefore" rows="2" class="input" style="border-radius: 6px; width: 100%; margin-bottom: 10px;"></textarea>

  <label>📝 Kommentar <strong>nach dem Trade</strong>:</label>
  <textarea id="journalNotesAfter" rows="2" class="input" style="border-radius: 6px; width: 100%; margin-bottom: 10px;"></textarea>

  <label for="screenshotInput">📸 Screenshots hochladen (optional):</label>
  <input type="file" id="screenshotInput" accept="image/*" multiple class="input" style="margin-bottom: 15px;" />

  <button id="saveJournalEntryButton" onclick="saveJournalEntry()" style="
    background-color: #0077cc;
    color: white;
    padding: 14px;
    border: none;
    border-radius: 8px;
    margin-top: 10px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    width: 100%;
  ">💾 Eintrag speichern</button>
</div>




<div id="lightboxOverlay" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.8); justify-content:center; align-items:center; z-index:9999;" onclick="closeLightbox()">
  <img id="lightboxImage" src="" alt="Bild" style="max-width:90vw; max-height:90vh; border-radius:10px; box-shadow: 0 0 20px #000;" />
</div>

<div style="margin-top:20px; text-align:center;">
  <button onclick="resetCurrentMonth()" style="margin:5px; background:#cc6600; color:white; padding:8px 15px; border:none; border-radius:5px;">🗓️ Monat zurücksetzen</button>
  <button onclick="resetSelectedDay()" style="margin:5px; background:#0066cc; color:white; padding:8px 15px; border:none; border-radius:5px;">📅 Tag zurücksetzen</button>
  <button onclick="resetAllJournal()" style="margin:5px; background:#990000; color:white; padding:8px 15px; border:none; border-radius:5px;">🗑️ Alles löschen</button>
</div>

<!-- 🔍 Lightbox für vergrößerte Bilder -->
<div id="lightboxOverlay" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.8); justify-content:center; align-items:center; z-index:9999;" onclick="closeLightbox()">
  <img id="lightboxImage" src="" alt="Full Screenshot" style="max-width:90vw; max-height:90vh; border-radius:10px; box-shadow: 0 0 20px #000;" />
</div>


<input type="file" id="screenshotInput" accept="image/*" multiple>

<div class="popup" id="resultPopup">
  <h3>Ergebnis</h3>
  <input type="text" inputmode="decimal" id="pnlInput" placeholder="z. B. 120.50" value="00,00" />
  <button onclick="saveResult()">Speichern</button>
</div>
<div id="syncStatus" style="text-align:center; color:#00ff99; font-weight:bold; margin-top:10px;"></div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
let planMode = "steuer";

function switchPlanMode() {
  const steuerDiv = document.getElementById("steuerMode");
  const nettoDiv = document.getElementById("nettoMode");
  const toggleBtn = document.getElementById("planToggleBtn");

  if (planMode === "steuer") {
    planMode = "netto";
    steuerDiv.style.display = "none";
    nettoDiv.style.display = "block";
    toggleBtn.textContent = "🔁 Zurück zum Steuerplaner";
  } else {
    planMode = "steuer";
    steuerDiv.style.display = "block";
    nettoDiv.style.display = "none";
    toggleBtn.textContent = "🔁 Zu Netto-Planer wechseln";
  }
}

function berechneSteuern() {
  const betrag = parseFloat(document.getElementById("gewinnBetrag").value);
  const estSatz = parseFloat(document.getElementById("einkommenSteuer").value);
  const mitKirche = document.getElementById("kirchensteuer").checked;
  const mitSoli = document.getElementById("soliZuschlag").checked;
  const mitReserve = document.getElementById("reserveZehn").checked;
  const ausgabe = document.getElementById("steuerAusgabe");

  if (isNaN(betrag) || isNaN(estSatz) || betrag <= 0 || estSatz <= 0) {
    ausgabe.innerHTML = "❌ Bitte Gewinn & Steuersatz korrekt eingeben!";
    ausgabe.style.color = "#f44";
    return;
  }

  const est = betrag * (estSatz / 100);
  const kirche = mitKirche ? est * 0.09 : 0;
  const soli = mitSoli ? est * 0.055 : 0;
  const reserve = mitReserve ? betrag * 0.10 : 0;

  const steuerlast = est + kirche + soli;
  const netto = betrag - steuerlast;
  const vorauszahlung = steuerlast / 4;

  let output = "";
  output += `📊 <strong>Summe Gewinne:</strong> ${betrag.toFixed(2)} €<br>`;
  output += `💸 <strong>Einkommensteuer:</strong> ${est.toFixed(2)} €<br>`;
  if (mitKirche) output += `✝️ Kirchensteuer: ${kirche.toFixed(2)} €<br>`;
  if (mitSoli) output += `💣 Soli: ${soli.toFixed(2)} €<br>`;
  if (mitReserve) output += `💥 Reserve: ${reserve.toFixed(2)} €<br>`;
  output += `<br>📦 <strong>Gesamtsteuerlast:</strong> ${steuerlast.toFixed(2)} €<br>`;
  output += `💰 <strong>Netto-Gewinn:</strong> ${netto.toFixed(2)} €<br><br>`;
  output += `🔮 <strong>Vorauszahlung nächstes Jahr (vierteljährlich):</strong> ${vorauszahlung.toFixed(2)} €`;

  ausgabe.innerHTML = output;
  ausgabe.style.color = "#0f0";

  // 💾 Nur Steuerplan speichern
  localStorage.setItem("lastTaxPlan", JSON.stringify({
    betrag, est, kirche, soli, reserve, steuerlast, netto, vorauszahlung,
    timestamp: new Date().toISOString()
  }));

  // 🔁 Nur live Netto-Werte setzen (nicht speichern)
  document.getElementById("nettoBrutto").value = betrag.toFixed(2);
  document.getElementById("nettoSteuer").value = steuerlast.toFixed(2);
  document.getElementById("nettoEntnommen").value = "";
  document.getElementById("nettoAusgabe").innerHTML = "";
}



function berechneNettoPlan() {
  const brutto = parseFloat(document.getElementById("nettoBrutto").value);
  const steuer = parseFloat(document.getElementById("nettoSteuer").value);
  const entnommen = parseFloat(document.getElementById("nettoEntnommen").value);
  const ausgabe = document.getElementById("nettoAusgabe");

  if ([brutto, steuer, entnommen].some(v => isNaN(v))) {
    ausgabe.innerHTML = "❌ Bitte alle Felder korrekt ausfüllen!";
    ausgabe.style.color = "#f44";
    return;
  }

  const netto = brutto - steuer;
  const differenz = entnommen - netto;

  let output = `📦 Netto-Gewinn (nach Steuer): <strong>${netto.toFixed(2)} €</strong><br>`;
  output += `🏦 Entnommen: ${entnommen.toFixed(2)} €<br><br>`;

  if (differenz > 0) {
    output += `⚠️ Du hast <strong>${differenz.toFixed(2)} €</strong> zu viel entnommen.<br>`;
    output += `💡 Empfehlung: Beim nächsten Gewinn mindestens <strong>${differenz.toFixed(2)} €</strong> zurücklegen.`;
    ausgabe.style.color = "#ffaa00";
  } else {
    output += `✅ Entnahme im Rahmen. Kein Ausgleich nötig.`;
    ausgabe.style.color = "#0f0";
  }

  ausgabe.innerHTML = output;

  // 🔁 Rücklagen-Merkung speichern
  localStorage.setItem("nettoPlanMemory", JSON.stringify({
    brutto, steuer, entnommen, differenz,
    timestamp: new Date().toISOString()
  }));
}


function switchCalcTab(tab) {
  document.querySelectorAll(".calc-box").forEach(box => box.style.display = "none");
  const target = document.getElementById("calc-" + tab);
  if (target) target.style.display = "block";

  document.querySelectorAll(".tab-buttons .btn").forEach(btn => btn.classList.remove("active"));
  const btn = document.getElementById("btn-calc-" + tab);
  if (btn) btn.classList.add("active");
}

window.addEventListener("DOMContentLoaded", () => {
  // Steuerplan NICHT automatisch in Netto übernehmen
  document.getElementById("nettoBrutto").value = "";
  document.getElementById("nettoSteuer").value = "";
  document.getElementById("nettoEntnommen").value = "";
  document.getElementById("nettoAusgabe").innerHTML = "";
});






</script>


</script>




<script>
document.getElementById("journalEntry").addEventListener("input", autoCalculateExit);
document.getElementById("journalDirection").addEventListener("change", autoCalculateExit);

function autoCalculateExit() {
  const entryInput = document.getElementById("journalEntry");
  const exitInput = document.getElementById("journalExit");
  const direction = document.getElementById("journalDirection")?.value?.toLowerCase() || "long";

  let entry = parseFloat(entryInput.value.replace(",", "."));
  if (isNaN(entry)) return;

  const decimals = (entry.toString().split(".")[1] || "").length;
  const step = Math.pow(10, -decimals || 1); // fallback auf 0.1

  const exit = direction === "short"
    ? entry - step
    : entry + step;

  exitInput.value = exit.toFixed(decimals);
}

</script>
<script>


let currentMonthOffset = 0;
function onRuleChanged() {
  updateRuleCount();
  updateSetupScoreDisplay(); // 🔁 Kein Delay mehr
}
function saveJournalEntry() {
  const files = document.getElementById("screenshotInput")?.files || [];
  const manualDate = document.getElementById("journalManualDate")?.value;
  const tradingMode = document.getElementById("tradingMode")?.value || "day";
  const editId = document.getElementById("saveJournalEntryButton").dataset.editId;
  const allEntries = JSON.parse(localStorage.getItem("journalData") || "[]");
  const selectedBiasFrames = Array.from(document.querySelectorAll('#biasTimeframes input:checked'))
    .map(cb => cb.value);

  // ✏️ Wenn Bearbeitung → alten Eintrag holen und überschreiben
  let entry;
  if (editId) {
    const existing = allEntries.find(e => e.id == editId);
    entry = {
      ...existing,
      id: parseInt(editId),
      date: manualDate ? new Date(manualDate).toISOString() : new Date().toISOString(),
      images: existing.images || { before: [], after: [] }  // ⬅️ beibehalten
    };
  } else {
    entry = {
      id: Date.now(),
      date: manualDate ? new Date(manualDate).toISOString() : new Date().toISOString(),
      images: { before: [], after: [] }  // ⬅️ neu
    };
  }

  // 🧠 Immer updaten
  Object.assign(entry, {
    pair: document.getElementById("journalSymbol").value.trim(),
    direction: document.getElementById("journalDirection").value.toLowerCase(),
    entry: parseFloat(document.getElementById("journalEntry").value),
    exit: parseFloat(document.getElementById("journalExit").value),
    lots: parseFloat(document.getElementById("journalLots").value),
    pnl: parseFloat(document.getElementById("journalPnL").value.replace(",", ".")),
    emotionBefore: parseInt(document.getElementById("emotionBefore").value),
    emotionAfter: parseInt(document.getElementById("emotionAfter").value),
    tradingMode,
    biasTimeframes: selectedBiasFrames,
    ruleAOI: document.getElementById("ruleAOI")?.checked || false,
    ruleEntry: document.getElementById("ruleEntry")?.checked || false,
    rulePsych: document.getElementById("rulePsych")?.checked || false,
    ruleSession: document.getElementById("ruleSession")?.checked || false,
    ruleRR: document.getElementById("ruleRR")?.checked || false,
    ruleLTFShift: document.getElementById("ruleLTFShift")?.checked || false,
    ruleEntrySignal: document.getElementById("ruleEntrySignal")?.checked || false,
    notesBefore: document.getElementById("journalNotesBefore")?.value.trim(),
    notesAfter: document.getElementById("journalNotesAfter")?.value.trim()
  });

  // 📸 Bildzuweisung
  if (files.length === 0) {
    finishSave(entry, editId, allEntries);
  } else {
    const targetArray = editId ? entry.images.after : entry.images.before;
    let loaded = 0;
    Array.from(files).forEach(file => {
      const reader = new FileReader();
      reader.onload = function (e) {
        const base64 = e.target.result;
        const imageId = "img_" + Date.now() + "_" + Math.floor(Math.random() * 100000);
        saveImageToIndexedDB(base64, imageId);
        targetArray.push(imageId);
        loaded++;
        if (loaded === files.length) {
          finishSave(entry, editId, allEntries);
        }
      };
      reader.readAsDataURL(file);
    });
  }
}



function finishSave(entry, editId, allEntries) {
  if (editId) {
    const index = allEntries.findIndex(e => e.id == editId);
    if (index !== -1) allEntries[index] = entry;
    delete document.getElementById("saveJournalEntryButton").dataset.editId;
  } else {
    allEntries.push(entry);
  }

  localStorage.setItem("journalData", JSON.stringify(allEntries));
  buildJournalCalendar(currentMonthOffset || 0);
  document.getElementById("calc-journal").style.display = "none";
  alert("✅ Journal-Eintrag gespeichert!");
}







function populateLotOptions() {
  const lotSelect = document.getElementById("journalLots");
  lotSelect.innerHTML = ""; // leeren

  const add = (val) => {
    const opt = document.createElement("option");
    opt.value = val.toFixed(2);
    opt.textContent = val.toFixed(2);
    lotSelect.appendChild(opt);
  };

  // Mikrolots (0.01 – 0.09)
  for (let i = 1; i <= 9; i++) add(i / 100);

  // Mini bis Standardlots (0.10 – 1.00)
  for (let i = 10; i <= 100; i += 5) add(i / 100);

  // Größere Schritte (1.00 – 10.00)
  for (let i = 2; i <= 10; i++) add(i);

  // Noch größere Schritte (15 – 100)
  for (let i = 15; i <= 100; i += 5) add(i);
}

function populateLotSuggestions() {
  const datalist = document.getElementById("lotOptions");
  datalist.innerHTML = "";

  const add = (val) => {
    const opt = document.createElement("option");
    opt.value = val.toFixed(2);
    datalist.appendChild(opt);
  };

  // 0.01 – 0.10 (Scalping)
  for (let i = 1; i <= 10; i++) add(i / 100);

  // 0.10 – 1.00 in 0.10er Schritten
  for (let i = 2; i <= 10; i++) add(i / 10);

  // 1.00 – 10.00 in 1er Schritten
  for (let i = 1; i <= 10; i++) add(i);

  // 15 – 100 in 5er Schritten
  for (let i = 15; i <= 100; i += 5) add(i);
}




function getSetupScore(entry) {
  const tfList = entry.biasTimeframes || [];
  const mode = entry.tradingMode || "day";

  // ❗ Mindestens 2 Bias-TFs erforderlich → kein gültiger Entry
  if (tfList.length < 2) return { score: 0, valid: false };

  let score = 0;

  // ✅ Bias Timeframes (max 30 %)
  score += Math.min(tfList.length, 3) * 10;

  // AOI (10 %)
  if (entry.ruleAOI) score += 10;

  // AOI-Zeitframe korrekt (10 %)
  const isAOICorrect =
    (mode === "swing" && tfList.includes("4H") && tfList.includes("D1")) ||
    (mode === "day" && tfList.includes("1H"));
  if (isAOICorrect) score += 10;

  // Entry Confirmation (10 %)
  if (entry.ruleEntry) score += 10;

  // Psychologische Levels (5 %)
  if (entry.rulePsych) score += 5;

  // Session-Zeitfenster (5 %)
  if (entry.ruleSession) score += 5;

  // CRV erfüllt (5 %)
  if (entry.ruleRR) score += 5;
  
  if (entry.ruleLTFShift) score += 10;
if (entry.ruleEntrySignal) score += 10;

  return {
    score: Math.min(score, 95),
    valid: true
  };
}


function openLightbox(src) {
  const overlay = document.getElementById("lightboxOverlay");
  const img = document.getElementById("lightboxImage");
  img.src = src;
  overlay.style.display = "flex";
}

function closeLightbox() {
  const overlay = document.getElementById("lightboxOverlay");
  const img = document.getElementById("lightboxImage");
  overlay.style.display = "none";
  img.src = "";
}

function updateBiasOptions() {
  const mode = document.getElementById("tradingMode")?.value || "day";
  const allowed = mode === "day" ? ["1H", "4H", "D1"] : ["4H", "D1", "W1"];

  document.querySelectorAll('#biasTimeframes input').forEach(cb => {
    const tf = cb.value;
    const label = cb.closest("label");
    if (allowed.includes(tf)) {
      label.style.display = "inline-flex";
    } else {
      cb.checked = false; // abwählen falls nicht erlaubt
      label.style.display = "none";
    }
  });

  updateSetupScoreDisplay(); // gleich aktualisieren
}


function getLiveSetupScoreFromForm() {
  const tfList = Array.from(document.querySelectorAll('#biasTimeframes input:checked')).map(cb => cb.value);
  const mode = document.getElementById("tradingMode")?.value || "day";

  let score = 0;

  // 📌 Bias-Timeframes (max 3 TFs à 10 %)
  score += Math.min(tfList.length, 3) * 10;

  // 📌 AOI (Area of Interest)
  if (document.getElementById("ruleAOI")?.checked) score += 10;

  // 📌 AOI-Timeframe korrekt (je nach Modus)
  const hasValidAOITF =
    (mode === "swing" && tfList.includes("4H") && tfList.includes("D1")) ||
    (mode === "day" && tfList.includes("1H"));
  if (hasValidAOITF) score += 10;

  // 📌 Weitere Regelpunkte
  if (document.getElementById("ruleEntry")?.checked) score += 10;       // Entry Confirmation
  if (document.getElementById("rulePsych")?.checked) score += 5;        // Psych Level
  if (document.getElementById("ruleSession")?.checked) score += 5;      // Session
  if (document.getElementById("ruleRR")?.checked) score += 5;           // Risk:Reward
  if (document.getElementById("ruleLTFShift")?.checked) score += 10;    // LTF Shift
  if (document.getElementById("ruleEntrySignal")?.checked) score += 10; // Signal

  // 📌 Endscore (A+ bei Day schon ab 85 %)
  const cappedScore = Math.min(score, 95); // Maximal 95 %
  const validBias = tfList.length >= 2;    // mindestens 2 Bias-TFs erforderlich

  return {
    score: cappedScore,
    validBias
  };
}





function updateSetupScoreDisplay() {
  const result = getLiveSetupScoreFromForm();
  const score = result.score;
  const hasBias = result.validBias;

  let verdict = "❌ Nicht gültig (mind. 2 Bias-TFs)";
  let textColor = "#ff4444";

  if (hasBias && score >= 95) {
    verdict = "✅ Perfekt";
    textColor = "#33ff77";
  } else if (hasBias && score >= 80) {
    verdict = "🟢 Sehr stark";
    textColor = "#55ff88";
  } else if (hasBias && score >= 60) {
    verdict = "🟨 Solide";
    textColor = "#ffff66";
  } else if (hasBias && score >= 40) {
    verdict = "🟧 Mittelmäßig";
    textColor = "#ffcc66";
  } else if (hasBias && score >= 20) {
    verdict = "🟥 Schwach";
    textColor = "#ff8888";
  } else if (hasBias) {
    verdict = "🔴 Katastrophal";
    textColor = "#ff4444";
  }

  // 🔁 Farbverlauf für Box
  const wrapper = document.getElementById("setupBoxWrapper");
  if (score >= 95) {
    wrapper.style.background = "linear-gradient(135deg, #0d3c0d, #1f6b1f)";
    wrapper.style.borderColor = "#33aa33";
    wrapper.style.boxShadow = "0 0 8px rgba(50, 255, 100, 0.3)";
  } else if (score >= 80) {
    wrapper.style.background = "linear-gradient(135deg, #2f5e2f, #4cc94c)";
    wrapper.style.borderColor = "#55dd55";
    wrapper.style.boxShadow = "0 0 8px rgba(100, 255, 100, 0.25)";
  } else if (score >= 60) {
    wrapper.style.background = "linear-gradient(135deg, #706f1a, #a8d94c)";
    wrapper.style.borderColor = "#cccc55";
    wrapper.style.boxShadow = "0 0 8px rgba(220, 255, 100, 0.2)";
  } else if (score >= 40) {
    wrapper.style.background = "linear-gradient(135deg, #8f631a, #d9b24c)";
    wrapper.style.borderColor = "#ddaa55";
    wrapper.style.boxShadow = "0 0 8px rgba(255, 220, 100, 0.2)";
  } else if (score >= 20) {
    wrapper.style.background = "linear-gradient(135deg, #8f2f2f, #d94c4c)";
    wrapper.style.borderColor = "#cc5555";
    wrapper.style.boxShadow = "0 0 8px rgba(255, 100, 100, 0.2)";
  } else {
    wrapper.style.background = "linear-gradient(135deg, #3d1e1e, #6b2f2f)";
    wrapper.style.borderColor = "#aa3333";
    wrapper.style.boxShadow = "0 0 8px rgba(255, 50, 50, 0.25)";
  }

  let letterGrade = "F"; // Default

if (score >= 95) letterGrade = "A+";
else if (score >= 80) letterGrade = "A";
else if (score >= 60) letterGrade = "B";
else if (score >= 40) letterGrade = "C";
else if (score >= 20) letterGrade = "D";

// Ergebnis anzeigen mit Schatten
document.getElementById("setupScoreDisplay").innerHTML = `
  📊 Setup-Score: <strong style="color:${textColor}; text-shadow: 0 0 2px black, 1px 1px 1px black;">
    ${score}% (${letterGrade})
  </strong> – <span style="text-shadow: 0 0 2px black, 1px 1px 1px black;">${verdict}</span>
`;

}



updateSetupScoreDisplay();

function renderStars(value) {
  const v = Math.max(1, Math.min(10, parseInt(value) || 0));
  return "⭐".repeat(v) + "☆".repeat(10 - v) + ` (${v}/10)`;
}

function setupStarRating(containerId, inputId) {
  const container = document.getElementById(containerId);
  const input = document.getElementById(inputId);

  for (let i = 10; i >= 1; i--) {
    const star = document.createElement("span");
    star.innerHTML = "★";
    star.dataset.value = i;
    star.onclick = () => {
      input.value = i;
      updateStarVisuals(containerId, i);
    };
    container.appendChild(star);
  }

  updateStarVisuals(containerId, parseInt(input.value));
}

function updateStarVisuals(containerId, value) {
  const container = document.getElementById(containerId);
  const stars = container.querySelectorAll("span");
  stars.forEach(s => {
    s.classList.toggle("selected", parseInt(s.dataset.value) <= value);
  });

  // Textanzeige je nach Bewertung
  const labelMap = {
    1: "😵 Totale Unsicherheit / komplett unklar",
    2: "😣 Sehr unsicher – kein Vertrauen in Setup",
    3: "😕 Zweifelnd – nicht wirklich ready",
    4: "😐 Neutral – etwas unklar, leichte Unruhe",
    5: "🙂 Leicht fokussiert – Setup okay",
    6: "😌 Zunehmend sicher – aber noch vorsichtig",
    7: "😎 Gute Kontrolle – vertraue dem Plan",
    8: "🔥 Scharfer Fokus – Setup passt perfekt",
    9: "💪 Volles Vertrauen – komplett im Flow",
    10: "🧠 100 % Fokus – State of Zen / Maschinenmodus"
  };

  // Bestehendes Text-Element finden oder neu anlegen
  let description = container.querySelector(".star-description");
  if (!description) {
    description = document.createElement("div");
    description.className = "star-description";
    description.style.marginTop = "4px";
    description.style.color = "#ccc";
    description.style.fontSize = "13px";
    container.appendChild(description);
  }

  description.textContent = labelMap[value] || "";
}


const knownSymbols = [
  // 🔹 Forex
  "EUR/USD", "GBP/USD", "USD/JPY", "USD/CHF", "AUD/USD", "NZD/USD", "USD/CAD",
  "EUR/JPY", "GBP/JPY", "CHF/JPY", "AUD/JPY", "CAD/JPY", "EUR/GBP", "EUR/CHF",
  "GBP/CHF", "AUD/NZD", "EUR/AUD", "EUR/CAD", "GBP/CAD", "GBP/NZD", "NZD/JPY", "NZD/CAD",

  // 🔹 Krypto (CFDs)
  "BTC/USD", "ETH/USD", "SOL/USD", "XRP/USD", "LTC/USD", "ADA/USD", "BCH/USD",

  // 🔹 Metalle (Spot & Futures CFDs)
  "XAU/USD", // Gold
  "XAG/USD", // Silber
  "XPT/USD", // Platin
  "XPD/USD", // Palladium
  "COPPER/USD", // Kupfer
  "ALUMINIUM/USD",
  "LEAD/USD",
  "ZINC/USD",

  // 🔹 Energie/Rohstoffe
  "WTI/USD",       // WTI Crude Oil
  "BRENT/USD",     // Brent Crude Oil
  "NATGAS/USD",    // Natural Gas
  "SOYBEAN/USD",   // Sojabohnen
  "SUGAR/USD",     // Zucker

  // 🔹 Indizes (zur Orientierung – obwohl du nur 1–4 wolltest)
  "US30", "NAS100", "SPX500", "GER40", "UK100"
];


function suggestSymbol() {
  const input = document.getElementById("journalSymbol");
  const suggestionsBox = document.getElementById("symbolSuggestions");
  const query = input.value.toUpperCase().trim();

  if (!query || query.length < 1) {
    suggestionsBox.style.display = "none";
    suggestionsBox.innerHTML = "";
    return;
  }

  const matches = knownSymbols.filter(sym => sym.includes(query));
  suggestionsBox.innerHTML = matches.map(sym => `
    <div style="padding:4px; cursor:pointer;" onclick="selectSymbol('${sym}')">${sym}</div>
  `).join("");
  suggestionsBox.style.display = matches.length ? "block" : "none";
}

function selectSymbol(symbol) {
  document.getElementById("journalSymbol").value = symbol;
  document.getElementById("symbolSuggestions").style.display = "none";
  document.getElementById("symbolSuggestions").innerHTML = "";
}

function getPnLStatsByDay(entries) {
  const daily = {};
  entries.forEach(entry => {
    const date = new Date(entry.date).toISOString().split("T")[0];
    daily[date] = (daily[date] || 0) + (parseFloat(entry.pnl) || 0);
  });
  return daily;
}

function buildJournalCalendar(monthOffset = 0) {
  const now = new Date();
  const currentMonth = new Date(now.getFullYear(), now.getMonth() + monthOffset, 1);
  const year = currentMonth.getFullYear();
  const month = currentMonth.getMonth();
  currentMonthOffset = monthOffset;

  const titleEl = document.getElementById("calendarTitle");
  if (titleEl) {
    titleEl.textContent = `📅 ${currentMonth.toLocaleString("de-DE", { month: "long" })} ${year}`;
  }

  const entries = JSON.parse(localStorage.getItem("journalData") || "[]");
  const dailyStats = getPnLStatsByDay(entries);
  const days = {};
  entries.forEach(e => {
    const d = new Date(e.date).toISOString().split("T")[0];
    days[d] = (days[d] || 0) + parseFloat(e.pnl || 0);
  });

  const greenDays = Object.values(days).filter(pnl => pnl > 0).length;
  const redDays = Object.values(days).filter(pnl => pnl < 0).length;
  const totalDays = greenDays + redDays;
  const greenRate = totalDays ? (greenDays / totalDays * 100).toFixed(1) : null;

  const firstDay = new Date(year, month, 1).getDay();
  const daysInMonth = new Date(year, month + 1, 0).getDate();
  const manualDateInput = document.getElementById("journalManualDate");

  let activeCalendarCell = null;
  const calendar = document.createElement("div");
  calendar.style.display = "grid";
  calendar.style.gridTemplateColumns = "repeat(7, 1fr)";
  calendar.style.gap = "5px";

  ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"].forEach(day => {
    const d = document.createElement("div");
    d.textContent = day;
    d.style.textAlign = "center";
    d.style.color = "#0ff";
    calendar.appendChild(d);
  });

  for (let i = 0; i < firstDay; i++) {
    calendar.appendChild(document.createElement("div"));
  }

for (let day = 1; day <= daysInMonth; day++) {
  const dateStr = `${year}-${String(month + 1).padStart(2, "0")}-${String(day).padStart(2, "0")}`;
  const pnl = dailyStats[dateStr] || 0;

  const cell = document.createElement("div");
  cell.textContent = day;
  cell.style.padding = "10px";
  cell.style.borderRadius = "6px";
  cell.style.textAlign = "center";
  cell.style.cursor = "pointer";
  cell.style.transition = "outline 0.2s ease";

  const tradesOnDay = entries.filter(e => e.date.startsWith(dateStr));

  const withPnL = tradesOnDay.filter(e =>
    e.pnl !== undefined && e.pnl !== null && e.pnl !== "" && !isNaN(parseFloat(e.pnl))
  );
  const openTrades = tradesOnDay.length - withPnL.length;

  const pnls = withPnL.map(e => parseFloat(e.pnl));
  const hasGain = pnls.some(v => v > 0);
  const hasLoss = pnls.some(v => v < 0);

  // 🎨 Farbentscheidung:
  if (openTrades > 0 && hasGain && hasLoss) {
    cell.style.background = "linear-gradient(135deg, #FFA500 33%, #228B22 33%, #228B22 66%, #B22222 66%)"; // Orange + Grün + Rot
  } else if (openTrades > 0 && hasGain) {
    cell.style.background = "linear-gradient(135deg, #FFA500 50%, #228B22 50%)"; // Orange + Grün
  } else if (openTrades > 0 && hasLoss) {
    cell.style.background = "linear-gradient(135deg, #FFA500 50%, #B22222 50%)"; // Orange + Rot
  } else if (openTrades > 0) {
    cell.style.background = "#FFA500"; // Nur offen
  } else if (hasGain && hasLoss) {
    cell.style.background = "linear-gradient(135deg, #228B22 50%, #B22222 50%)"; // Grün + Rot
  } else {
    const sum = pnls.reduce((a, b) => a + b, 0);
    cell.style.background = sum > 0 ? "#228B22" : (sum < 0 ? "#B22222" : "#777"); // Grün / Rot / Neutral
  }

  cell.style.color = "white";

  cell.onclick = () => {
    showEntriesForDate(dateStr);
    if (activeCalendarCell) activeCalendarCell.style.outline = "";
    cell.style.outline = "2px solid #3399ff";
    activeCalendarCell = cell;
    if (manualDateInput) manualDateInput.value = dateStr;

    const journalBox = document.getElementById("calc-journal");
    if (journalBox) {
      journalBox.style.display = "block";
      window.scrollTo({ top: journalBox.offsetTop - 40, behavior: "smooth" });
    }
  };

  calendar.appendChild(cell);
}



  document.getElementById("calendarContainer").innerHTML = "";
  document.getElementById("calendarContainer").appendChild(calendar);

  const currentMonthKey = `${year}-${String(month + 1).padStart(2, "0")}`;
  const monthlyEntries = entries
    .filter(e => e.date.startsWith(currentMonthKey))
    .sort((a, b) => new Date(a.date) - new Date(b.date));
let validSetups = 0;
let shakySetups = 0;
let failedSetups = 0;

monthlyEntries.forEach(e => {
  const result = getSetupScore(e);
  const score = result?.score ?? 0;
  const valid = result?.valid ?? false;

  if (!valid) {
    failedSetups++;
  } else if (score >= 40) {
    validSetups++;
  } else if (score >= 20) {
    shakySetups++;
  } else {
    failedSetups++;
  }
});



  // 📈 Equity-Kurve
  let equity = 0;
  let peak = 0;
  let maxDrawdown = 0;
  const equityData = [0];
  const labels = ['Start'];

  monthlyEntries.forEach((e, i) => {
    equity += parseFloat(e.pnl || 0);
    equityData.push(equity);
    labels.push(`#${i + 1}`);
    if (equity > peak) peak = equity;
    const dd = ((peak - equity) / peak) * 100;
    if (dd > maxDrawdown) maxDrawdown = dd;
  });

  const ctx = document.getElementById("calendarEquityChart").getContext("2d");
  if (window.calendarEquityChartInstance) window.calendarEquityChartInstance.destroy();
  window.calendarEquityChartInstance = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [{
        label: 'Equity-Kurve',
        data: equityData,
        borderWidth: 2,
        borderColor: '#00ff99',
        backgroundColor: 'rgba(0,255,153,0.1)',
        fill: true,
        tension: 0.3,
        pointRadius: 0
      }]
    },
    options: {
      responsive: true,
      scales: {
        x: { title: { display: true, text: 'Trades im Monat' } },
        y: { title: { display: true, text: 'Kumulierte Performance (€)' } }
      },
      plugins: { legend: { display: false } }
    }
  });

  // 📊 Statistik
  const pnlPerDay = Object.values(days);
  const winTrades = monthlyEntries.filter(e => parseFloat(e.pnl) > 0);
  const lossTrades = monthlyEntries.filter(e => parseFloat(e.pnl) < 0);
  const totalWin = winTrades.reduce((sum, t) => sum + parseFloat(t.pnl || 0), 0);
  const totalLoss = lossTrades.reduce((sum, t) => sum + parseFloat(t.pnl || 0), 0);
  const avgPerDay = pnlPerDay.length ? pnlPerDay.reduce((a, b) => a + b, 0) / pnlPerDay.length : 0;
  const bestDay = pnlPerDay.length ? Math.max(...pnlPerDay) : null;
  const worstDay = pnlPerDay.length ? Math.min(...pnlPerDay) : null;
  const profitFactor = totalLoss !== 0 ? Math.abs(totalWin / totalLoss).toFixed(2) : "∞";
  const winRate = monthlyEntries.length > 0 ? (winTrades.length / monthlyEntries.length * 100).toFixed(1) : "–";

// 🔍 Klassifikationstage vorbereiten
const rulesByDay = {}; // { "2025-07-23": [true, false, true] }

monthlyEntries.forEach(e => {
  const day = new Date(e.date).toISOString().split("T")[0];
  if (!rulesByDay[day]) rulesByDay[day] = [];
  rulesByDay[day].push([
    e.ruleBias ?? false,
    e.ruleSession ?? false,
    e.ruleSetupValid ?? false
  ]);
});

// Tagesklassifikation
let perfectDays = 0;
let shakyDays = 0;
let failDays = 0;

for (const ruleSets of Object.values(rulesByDay)) {
  let merged = [false, false, false];
  ruleSets.forEach(rules => {
    for (let i = 0; i < 3; i++) {
      merged[i] = merged[i] || rules[i]; // irgendeine Regel erfüllt zählt
    }
  });
  const count = merged.filter(x => x).length;
  if (count === 3) perfectDays++;
  else if (count >= 1) shakyDays++;
  else failDays++;
}


document.getElementById("calendarStats").innerHTML = `
  <div id="monthlyOverview" style="margin-bottom:15px;">
    📅 Monat ${currentMonthKey} – <strong style="color:${equity >= 0 ? '#0f0' : '#f44'}">${equity.toFixed(2)} €</strong><br>
    💚 Bester Tag: <strong>${bestDay !== null ? bestDay.toFixed(2) : "–"} €</strong><br>
    💔 Schlechtester Tag: <strong>${worstDay !== null ? worstDay.toFixed(2) : "–"} €</strong><br>
    📉 Max Drawdown: <strong>${maxDrawdown.toFixed(2)}%</strong><br>
    📈 Trades: <strong>${monthlyEntries.length}</strong><br>
    🧾 Gewinn-Trades: <strong>${winTrades.length}</strong> / Verlust-Trades: <strong>${lossTrades.length}</strong><br>
    🧮 Ø/Tag: <strong>${avgPerDay.toFixed(2)} €</strong><br>
    ⚖️ Profitfaktor: <strong>${profitFactor}</strong><br>
    🎯 Trefferquote: <strong>${winRate}%</strong><br><br>


    🧠 <strong>Setup-Auswertung:</strong><br>
    ✅ Valide Setups: <strong>${validSetups}</strong><br>
    ⚠️ Wacklige Setups: <strong>${shakySetups}</strong><br>
    ❌ Regelbruch-Setups: <strong>${failedSetups}</strong>
  </div>
`;

}

function changeMonth(offset) {
  currentMonthOffset += offset;
  buildJournalCalendar(currentMonthOffset);
}

function editEntry(entryId) {
  const all = JSON.parse(localStorage.getItem("journalData") || "[]");
  const entry = all.find(e => e.id === entryId);
  if (!entry) return alert("❌ Eintrag nicht gefunden.");

  // 🧠 Werte ins Formular laden
  document.getElementById("journalManualDate").value = entry.date.split("T")[0];
  document.getElementById("journalSymbol").value = entry.pair;
  document.getElementById("journalDirection").value = entry.direction?.toLowerCase();
  document.getElementById("journalEntry").value = entry.entry;
  document.getElementById("journalExit").value = entry.exit;
  document.getElementById("journalLots").value = entry.lots;
  document.getElementById("journalPnL").value = entry.pnl;
  document.getElementById("emotionBefore").value = entry.emotionBefore;
  document.getElementById("emotionAfter").value = entry.emotionAfter;

  // ⭐ Update Sternanzeige richtig anzeigen
  updateStarVisuals("starsBefore", parseInt(entry.emotionBefore));
  updateStarVisuals("starsAfter", parseInt(entry.emotionAfter));

  // 📋 Regeln (Checkliste) setzen
  ["AOI", "Entry", "Psych", "Session", "RR", "LTFShift", "EntrySignal"].forEach(id => {
    const el = document.getElementById("rule" + id);
    if (el) el.checked = !!entry["rule" + id];
  });

  // Bias-TFs
  document.querySelectorAll('#biasTimeframes input').forEach(cb => {
    cb.checked = entry.biasTimeframes?.includes(cb.value) || false;
  });

  // Trading Mode
  document.getElementById("tradingMode").value = entry.tradingMode || "day";
  updateBiasOptions();

  // Setup-Score berechnen
  updateSetupScoreDisplay();

  // 🧠 Signal zum Überschreiben statt neu anlegen
  document.getElementById("saveJournalEntryButton").dataset.editId = entryId;

  // 🖊️ Formular anzeigen & hervorheben
  const formEl = document.getElementById("calc-journal");
  formEl.style.display = "block";

  // 🔽 Smooth scroll zum Formular mit Abstand (für Sticky Header etc.)
  const topOffset = formEl.getBoundingClientRect().top + window.scrollY - 60;
  window.scrollTo({ top: topOffset, behavior: "smooth" });

  // ✨ Visuelles Highlight für Feedback
  formEl.style.transition = "box-shadow 0.3s ease";
  formEl.style.boxShadow = "0 0 12px 4px #0077cc";
  setTimeout(() => {
    formEl.style.boxShadow = "none";
  }, 1000);
}


function showEntriesForDate(dateStr) {
  const entries = JSON.parse(localStorage.getItem("journalData") || "[]");
  const filtered = entries.filter(e => e.date.startsWith(dateStr));
  const list = document.getElementById("journalEntryList");
  list.innerHTML = `<h4>📅 ${dateStr} – ${filtered.length} Eintrag(e)</h4>`;

  if (filtered.length === 0) {
    list.innerHTML += "<p>❌ Keine Einträge gefunden.</p>";
    return;
  }

  filtered.forEach(entry => {
    const result = getSetupScore(entry);
    const score = result.score;
    const valid = result.valid;

    let verdict = "❌ Regelbruch";
    if (!valid) verdict = "❌ Nicht gültig (Bias fehlt)";
    else if (score >= 95) verdict = "✅ Perfekt";
    else if (score >= 80) verdict = "🟢 Sehr stark";
    else if (score >= 60) verdict = "🟨 Solide";
    else if (score >= 40) verdict = "🟧 Mittelmäßig";
    else if (score >= 20) verdict = "🟥 Schwach";

    const biasStr = entry.biasTimeframes?.join(" + ") || "–";
    const modeStr = entry.tradingMode || "–";

    const colorBox = entry.direction === "Long"
      ? "linear-gradient(135deg, #1e3d1e, #2f6b2f)"
      : "linear-gradient(135deg, #4a1e1e, #8b2f2f)";

    let pnlDisplay = "⏳ Offen";
    let pnlSummaryColor = "#aa5500";
    if (typeof entry.pnl === "number" && !isNaN(entry.pnl)) {
      pnlDisplay = `${entry.pnl} €`;
      pnlSummaryColor = entry.pnl > 0 ? "#1e5721" : entry.pnl < 0 ? "#8b2f2f" : "#666666";
    }

// 🔽 Bilder laden (getrennt nach Vorher/Nachher)
let imageHTML = "";

// Neue Struktur mit "before"/"after"
if (entry.images?.before?.length > 0 || entry.images?.after?.length > 0) {
  if (entry.images.before?.length > 0) {
    const beforeId = "img_before_" + entry.id;
    imageHTML += `
      <div style="margin-top: 10px;">
        <strong>📸 Vor dem Trade:</strong>
        <div id="${beforeId}" style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 5px;"></div>
      </div>
    `;
    setTimeout(() => {
      const el = document.getElementById(beforeId);
      if (el) {
        entry.images.before.forEach(id => {
          const box = document.createElement("div");
          box.textContent = "⏳";
          el.appendChild(box);
          loadImageFromIndexedDB(id, base64 => {
            box.innerHTML = `<img src="${base64}" style="max-width: 120px; border-radius: 6px; cursor: pointer;" onclick="showLightbox('${base64}')" />`;
          });
        });
      }
    }, 0);
  }

  if (entry.images.after?.length > 0) {
    const afterId = "img_after_" + entry.id;
    imageHTML += `
      <div style="margin-top: 10px;">
        <strong>📸 Nach dem Trade:</strong>
        <div id="${afterId}" style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 5px;"></div>
      </div>
    `;
    setTimeout(() => {
      const el = document.getElementById(afterId);
      if (el) {
        entry.images.after.forEach(id => {
          const box = document.createElement("div");
          box.textContent = "⏳";
          el.appendChild(box);
          loadImageFromIndexedDB(id, base64 => {
            box.innerHTML = `<img src="${base64}" style="max-width: 120px; border-radius: 6px; cursor: pointer;" onclick="showLightbox('${base64}')" />`;
          });
        });
      }
    }, 0);
  }
}

// 🔙 Fallback für alte Struktur (wenn entry.imageIds noch genutzt wird)
if (!entry.images && entry.imageIds?.length > 0) {
  const fallbackId = "img_fallback_" + entry.id;
  imageHTML += `
    <div style="margin-top: 10px;">
      <strong>📸 Bilder:</strong>
      <div id="${fallbackId}" style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 5px;"></div>
    </div>
  `;
  setTimeout(() => {
    const el = document.getElementById(fallbackId);
    if (el) {
      entry.imageIds.forEach(id => {
        const box = document.createElement("div");
        box.textContent = "⏳";
        el.appendChild(box);
        loadImageFromIndexedDB(id, base64 => {
          box.innerHTML = `<img src="${base64}" style="max-width: 120px; border-radius: 6px; cursor: pointer;" onclick="showLightbox('${base64}')" />`;
        });
      });
    }
  }, 0);
}






    list.innerHTML += `
      <details class="trade-box" style="margin-top: 10px; border-radius: 8px; overflow: hidden; background: ${colorBox};">
        <summary style="background: ${pnlSummaryColor}; color:#fff; padding: 8px 12px; font-weight: bold; cursor: pointer;">
          ${entry.pair} (${entry.direction}) – 💰 ${pnlDisplay}
        </summary>
        <div class="trade-details" style="background:#1a1a1a; color:#eee; padding: 12px;">
          ${renderStars(entry.emotionBefore)} Fokus<br>
          ${renderStars(entry.emotionAfter)} Nach dem Trade<br>
          🧭 Modus: <strong>${modeStr}</strong><br>
          📐 Bias-TFs: <strong>${biasStr}</strong><br>
          📊 Setup Score: <strong>${score}%</strong> – ${verdict}<br><br>

          <strong>📝 Kommentar vor dem Trade:</strong><br>
          ${entry.notesBefore || "–"}<br><br>

          <strong>📝 Kommentar nach dem Trade:</strong><br>
          ${entry.notesAfter || "–"}<br><br>

          ${imageHTML}

          <div style="display:flex; gap:10px; margin-top: 10px;">
            <button onclick="editEntry(${entry.id})"
              style="background:#0077cc; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">
              ✏️ Bearbeiten
            </button>
            <button onclick="deleteEntry(${entry.id})"
              style="background:#cc3333; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">
              🗑️ Löschen
            </button>
          </div>
        </div>
      </details>
    `;
  });
}

function loadImageFromIndexedDB(id, callback) {
  const request = indexedDB.open("TradeAppDB", 1);
  request.onsuccess = function(event) {
    const db = event.target.result;
    const tx = db.transaction("images", "readonly");
    const store = tx.objectStore("images");
    const getReq = store.get(id);
    getReq.onsuccess = () => {
      if (getReq.result) callback(getReq.result.image);
    };
  };
}

function showLightbox(src) {
  const overlay = document.getElementById("lightboxOverlay");
  const image = document.getElementById("lightboxImage");
  image.src = src;
  overlay.style.display = "flex";
}

function closeLightbox() {
  document.getElementById("lightboxOverlay").style.display = "none";
}


function deleteEntry(entryId) {
  if (!confirm("❌ Diesen Eintrag wirklich löschen?")) return;

  const all = JSON.parse(localStorage.getItem("journalData") || "[]");
  const updated = all.filter(e => e.id !== entryId);

  localStorage.setItem("journalData", JSON.stringify(updated));
  buildJournalCalendar(currentMonthOffset);
  document.getElementById("journalEntryList").innerHTML = "";
  alert("🗑️ Eintrag gelöscht.");
}



function resetCurrentMonth() {
  const entries = JSON.parse(localStorage.getItem("journalData") || "[]");
  const now = new Date();
  const monthKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
  const filtered = entries.filter(e => !e.date.startsWith(monthKey));

  localStorage.setItem("journalData", JSON.stringify(filtered));
  buildJournalCalendar(currentMonthOffset);
  document.getElementById("journalEntryList").innerHTML = "";
  alert(`✅ Alle Einträge für ${monthKey} wurden gelöscht.`);
}

function resetSelectedDay() {
  const selectedDate = document.getElementById("journalManualDate")?.value;
  if (!selectedDate) {
    alert("⚠️ Kein Tag ausgewählt.");
    return;
  }

  const entries = JSON.parse(localStorage.getItem("journalData") || "[]");
  const filtered = entries.filter(e => !e.date.startsWith(selectedDate));

  localStorage.setItem("journalData", JSON.stringify(filtered));
  buildJournalCalendar(currentMonthOffset);
  document.getElementById("journalEntryList").innerHTML = "";
  alert(`📅 Alle Einträge für ${selectedDate} wurden gelöscht.`);
}

function resetAllJournal() {
  if (confirm("⚠️ Bist du sicher, dass du ALLES löschen willst?")) {
    localStorage.removeItem("journalData");
    localStorage.removeItem("manualNotes");

    buildJournalCalendar(currentMonthOffset);
    document.getElementById("journalEntryList").innerHTML = "";
    document.getElementById("calc-journal").style.display = "none";

    alert("🗑️ Journal vollständig gelöscht.");
  }
}

window.addEventListener("DOMContentLoaded", () => {
  buildJournalCalendar();
  setupStarRating("starsBefore", "emotionBefore");
  setupStarRating("starsAfter", "emotionAfter");
  populateLotOptions();
  populateLotSuggestions();

  // Initial Setup-Score anzeigen, falls Bias ausgewählt ist
  if (document.querySelector('#biasTimeframes input:checked')) {
    updateSetupScoreDisplay();
  }
});

</script>

<script>
function calculatePositionSize() {
  const accountSize = parseFloat(document.getElementById("accountSize").value);
  const riskPercent = parseFloat(document.getElementById("riskPercent").value);
  const stopLossPips = parseFloat(document.getElementById("stopLossPips").value);
  const leverage = parseFloat(document.getElementById("leverage").value);
  const symbol = document.getElementById("symbolSelector").value;
  const manualLots = parseFloat(document.getElementById("manualLots")?.value);
  const resultEl = document.getElementById("positionSizeResult");

  const pipValues = {
    "XAU/USD": 100, "XAG/USD": 50,
    "BTC/USD": 30000, "ETH/USD": 1800,
    "US30": 10, "NAS100": 20, "SPX500": 10, "GER40": 25, "UK100": 10,
    "AUD/USD": 10, "EUR/USD": 10, "GBP/USD": 10, "NZD/USD": 10,
    "USD/CHF": 9.26, "USD/CAD": 7.94,
    "USD/JPY": 9.17, "EUR/JPY": 9.17, "GBP/JPY": 9.17,
    "CHF/JPY": 9.17, "AUD/JPY": 9.17, "NZD/JPY": 9.17, "CAD/JPY": 9.17,
    "EUR/GBP": 10, "EUR/AUD": 10, "EUR/CAD": 10,
    "GBP/AUD": 10, "GBP/CAD": 10, "AUD/CAD": 7.94
  };

  const basisWerte = {
    "XAU/USD": 200000, "XAG/USD": 125000, "BTC/USD": 30000, "ETH/USD": 1800,
    "US30": 10, "NAS100": 20, "SPX500": 10, "GER40": 25, "UK100": 10,
    "EUR/USD": 100000, "GBP/USD": 100000, "AUD/USD": 100000, "NZD/USD": 100000,
    "USD/CAD": 100000, "USD/CHF": 100000, "USD/JPY": 100000, "EUR/JPY": 100000,
    "GBP/JPY": 100000, "CHF/JPY": 100000, "AUD/JPY": 100000, "NZD/JPY": 100000,
    "CAD/JPY": 100000, "EUR/GBP": 100000, "EUR/AUD": 100000, "EUR/CAD": 100000,
    "GBP/AUD": 100000, "GBP/CAD": 100000, "AUD/CAD": 100000
  };

  const pipValueStandard = pipValues[symbol];
  const basis = basisWerte[symbol] || 100000;

  if (
    isNaN(accountSize) || isNaN(riskPercent) || isNaN(stopLossPips) ||
    isNaN(leverage) || accountSize <= 0 || riskPercent <= 0 ||
    stopLossPips <= 0 || leverage <= 0 || !pipValueStandard
  ) {
    resultEl.innerHTML = "❌ Bitte alle Felder korrekt ausfüllen!";
    resultEl.style.color = "#f44";
    return;
  }

  const riskAmount = accountSize * (riskPercent / 100);
  let baseLot = riskAmount / (stopLossPips * (pipValueStandard));
  const maxLots = (accountSize * leverage) / basis;
  let output = "";

  if (0.01 > maxLots) {
    resultEl.innerHTML = `❌ Mit diesem Hebel kannst du dir keine <strong>0.01 Lots</strong> leisten.<br>
      📏 Maximal erlaubt bei ${leverage}x Hebel: <strong>${maxLots.toFixed(4)} Lots</strong><br><br>
      Bitte Hebel oder Kapital erhöhen.`;
    resultEl.style.color = "#f44";
    return;
  }
const originalLot = baseLot;
  if (baseLot < 0.01) {
    output += `⚠️ Empfohlene Größe: <strong>${baseLot.toFixed(4)}</strong> Lots (unter 0.01)<br>`;
    output += `🔒 Mindestgröße: 0.01 Lots – Risiko kleiner als erwartet.<br><br>`;
    baseLot = 0.01;
  }

  // 📉 Risiko korrekt berechnen mit pipValue angepasst an Lotgröße
  const pipValueActual = pipValueStandard * baseLot;
  const risikoEuroEmpfohlen = stopLossPips * pipValueActual;
  const risikoProzentEmpfohlen = (risikoEuroEmpfohlen / accountSize) * 100;
  
  function getRiskComment(riskPercent) {
  if (riskPercent < 1) return "✅ Sehr konservativ";
  if (riskPercent < 2) return "🟢 Konservativ";
  if (riskPercent < 5) return "🟡 Neutral";
  if (riskPercent < 10) return "🟠 Erhöhtes Risiko";
  if (riskPercent < 20) return "🔴 Sehr hohes Risiko";
  return "🔥 Extrem riskant – nur für Profis!";
}

output += `<br>${getRiskComment(risikoProzentEmpfohlen)}<br><br>`;


 let risikoTitel = "📉 Dein Risiko:";
if (risikoProzentEmpfohlen >= 10) risikoTitel = "⚠️ Dein Risiko (nicht empfohlen):";
else if (risikoProzentEmpfohlen >= 5) risikoTitel = "🟠 Dein Risiko (grenzwertig):";
else if (risikoProzentEmpfohlen >= 2) risikoTitel = "🟡 Dein Risiko (moderat):";
else risikoTitel = "✅ Dein Risiko (empfohlen):";

output += `<strong>${risikoTitel}</strong><br>`;
  output += `💸 <strong>${risikoEuroEmpfohlen.toFixed(2)} €</strong> (${risikoProzentEmpfohlen.toFixed(2)} % von ${accountSize} €)<br><br>`;

  const steps = [1, 2, 3, 4, 5];
  output += `✅ Empfohlen: <strong>${(baseLot * steps[0]).toFixed(2)}</strong> Lots<br>`;
  output += `🟡 Riskant: ${(baseLot * steps[1]).toFixed(2)} Lots (Risiko ${(risikoProzentEmpfohlen * steps[1]).toFixed(1)}%)<br>`;
  output += `🟡 Riskant: ${(baseLot * steps[2]).toFixed(2)} Lots (Risiko ${(risikoProzentEmpfohlen * steps[2]).toFixed(1)}%)<br>`;
  output += `🔥 Hoch: ${(baseLot * steps[3]).toFixed(2)} Lots (Risiko ${(risikoProzentEmpfohlen * steps[3]).toFixed(1)}%)<br>`;
  output += `🧮 Sehr hoch: ${(baseLot * steps[4]).toFixed(2)} Lots (Risiko ${(risikoProzentEmpfohlen * steps[4]).toFixed(1)}%)<br>`;
  output += `⚠️ Mehr als ${(baseLot * steps[4]).toFixed(2)} Lots = über deinem Risiko-Limit<br><hr>`;
  output += `📏 Maximal erlaubt bei ${leverage}x Hebel: <strong>${maxLots.toFixed(2)} Lots</strong><br>`;

if (!isNaN(manualLots) && manualLots > 0) {
  const pipValueManuell = pipValueStandard * manualLots;
  const risikoEuroManuell = stopLossPips * pipValueManuell;
  const risikoProzentManuell = (risikoEuroManuell / accountSize) * 100;

  output += `<hr><strong>📉 Risiko bei manueller Lotgröße (${manualLots}):</strong><br>`;
  output += `💸 <strong>${risikoEuroManuell.toFixed(2)} €</strong> (${risikoProzentManuell.toFixed(2)} % von ${accountSize} €)<br>`;
}


  resultEl.innerHTML = output;
  resultEl.style.color = "#0f0";
}












function toggleInfoBox() {
  const box = document.getElementById("posInfoBox");
  box.style.display = box.style.display === "none" ? "block" : "none";
}

function calculateLotFromFixed() {
  const riskEuro = parseFloat(document.getElementById("lotFixedRisk").value);
  const sl = parseFloat(document.getElementById("lotSL").value);
  const pipVal = parseFloat(document.getElementById("lotPipValue").value);
  const out = document.getElementById("lotResult");

  if (isNaN(riskEuro) || isNaN(sl) || isNaN(pipVal) ||
      riskEuro <= 0 || sl <= 0 || pipVal <= 0) {
    out.innerHTML = "❌ Bitte alle Felder korrekt ausfüllen!";
    out.style.color = "#f44";
    return;
  }

  const lotSize = riskEuro / (sl * pipVal);

  out.innerHTML = `✅ Empfohlene Lotgröße: <strong>${lotSize.toFixed(2)}</strong> Lots`;
  out.style.color = "#0f0";
}

function toggleLotInfo() {
  const box = document.getElementById("lotInfoBox");
  box.style.display = box.style.display === "none" ? "block" : "none";
}


function togglePipMode() {
  const pipField = document.getElementById("riskPipValue");
  const tvNote = document.getElementById("tvNote");
  const checkbox = document.getElementById("useTradingView");

  if (checkbox.checked) {
    pipField.disabled = true;
    pipField.style.background = "#333";
    tvNote.style.display = "block";
  } else {
    pipField.disabled = false;
    pipField.style.background = "";
    tvNote.style.display = "none";
  }
}
function calculateRiskPercent() {
  const account = parseFloat(document.getElementById("riskAccountSize").value);
  const lot = parseFloat(document.getElementById("riskLotSize").value);
  const sl = parseFloat(document.getElementById("riskStopLoss").value);
  const useTV = document.getElementById("useTradingView").checked;
  const output = document.getElementById("riskResult");

  let pipVal = useTV ? 6.3 : parseFloat(document.getElementById("riskPipValue").value);

  if (
    isNaN(account) || isNaN(lot) || isNaN(sl) ||
    account <= 0 || lot <= 0 || sl <= 0 || isNaN(pipVal) || pipVal <= 0
  ) {
    output.innerHTML = "❌ Bitte alle Felder korrekt ausfüllen!";
    output.style.color = "#f44";
    return;
  }

  const riskEuro = lot * sl * pipVal;
  const riskPercent = (riskEuro / account) * 100;

  output.innerHTML = `⚠️ Du riskierst <strong>${riskEuro.toFixed(2)} €</strong>  
                      (${riskPercent.toFixed(2)} % deines Kontos)`;
  output.style.color = riskPercent <= 2 ? "#0f0" : (riskPercent <= 5 ? "#ffaa00" : "#f44");
}


function toggleRiskInfo() {
  const box = document.getElementById("riskInfoBox");
  box.style.display = box.style.display === "none" ? "block" : "none";
}

function calculateBreakeven() {
  const entry = parseFloat(document.getElementById("entryPrice").value);
  const spread = parseFloat(document.getElementById("spreadPips").value);
  const fees = parseFloat(document.getElementById("fees").value);
  const lot = parseFloat(document.getElementById("beLotSize").value);
  const pipVal = parseFloat(document.getElementById("bePipValue").value);
  const output = document.getElementById("breakevenResult");

  if (isNaN(entry) || isNaN(spread) || isNaN(fees) || isNaN(lot) || isNaN(pipVal) ||
      entry <= 0 || spread < 0 || fees < 0 || lot <= 0 || pipVal <= 0) {
    output.innerHTML = "❌ Bitte alle Felder korrekt ausfüllen!";
    output.style.color = "#f44";
    return;
  }

  const spreadValue = spread;
  const feeInPips = fees / (lot * pipVal);
  const totalPips = spreadValue + feeInPips;
  const pipSize = 0.0001; // Für Forex (z. B. EUR/USD), ggf. anpassbar
  const breakEvenPrice = entry + (totalPips * pipSize);

  output.innerHTML = `📍 Break-even liegt bei <strong>${breakEvenPrice.toFixed(5)}</strong>`;
  output.style.color = "#0ff";
}

function toggleBreakevenInfo() {
  const box = document.getElementById("breakevenInfoBox");
  box.style.display = box.style.display === "none" ? "block" : "none";
}



function toggleLeverageMode() {
  const mode = document.getElementById("leverageMode").value;
  document.getElementById("capitalMode").style.display = mode === "capital" ? "block" : "none";
  document.getElementById("lotCheckMode").style.display = mode === "lotcheck" ? "block" : "none";
  document.getElementById("leverageResult").innerHTML = "";
}

function calculateLeverage() {
  const mode = document.getElementById("leverageMode").value;
  const resultEl = document.getElementById("leverageResult");

  if (mode === "capital") {
    const capital = parseFloat(document.getElementById("leverageInput1").value);
    const lots = parseFloat(document.getElementById("leverageInput2").value);
    const leverage = parseFloat(document.getElementById("leverageInput3").value);

    if (isNaN(capital) || isNaN(lots) || isNaN(leverage) || capital <= 0 || lots <= 0 || leverage <= 0) {
      resultEl.innerHTML = "❌ Bitte alles korrekt eingeben!";
      resultEl.style.color = "#f44";
      return;
    }

    const benötigtesKapital = (lots * 100000) / leverage;
    resultEl.innerHTML = `📦 Du brauchst <strong>${benötigtesKapital.toFixed(2)} €</strong> Kapital für ${lots} Lot bei ${leverage}x Hebel`;
    resultEl.style.color = "#0f0";

  } else if (mode === "lotcheck") {
    const capital = parseFloat(document.getElementById("lotCapital").value);
    const leverage = parseFloat(document.getElementById("lotLeverage").value);
    const pair = document.getElementById("lotPair")?.value || "default";

    if (isNaN(capital) || isNaN(leverage) || capital <= 0 || leverage <= 0) {
      resultEl.innerHTML = "❌ Bitte Kapital und Hebel korrekt eingeben!";
      resultEl.style.color = "#f44";
      return;
    }

let basis;
switch (pair) {
  // Metalle
 case "XAU/USD": basis = 200000; break;
case "XAG/USD": basis = 125000; break;

  // Krypto
  case "BTC/USD": basis = 30000; break;
  case "ETH/USD": basis = 1800; break;

  // Indizes
  case "US30":    basis = 10; break;
  case "NAS100":  basis = 20; break;
  case "SPX500":  basis = 10; break;
  case "GER40":   basis = 25; break;
  case "UK100":   basis = 10; break;

  // Forex mit typischer 100k Kontraktgröße
  case "EUR/USD":
  case "GBP/USD":
  case "AUD/USD":
  case "NZD/USD":
  case "USD/CAD":
  case "USD/CHF":
    basis = 100000; break;

  // Forex mit leicht abweichendem Pip-Wert / Standard je nach Broker
  case "USD/JPY":
  case "EUR/JPY":
  case "GBP/JPY":
  case "CHF/JPY":
  case "AUD/JPY":
  case "CAD/JPY":
    basis = 100000; break; // Optional auf 1.000.000 JPY setzen, je nach Broker

  // Cross-Paare (ohne USD direkt)
  case "EUR/GBP":
  case "EUR/AUD":
  case "EUR/CAD":
  case "GBP/AUD":
  case "GBP/CAD":
    basis = 100000; break;

  default:
    basis = 100000; break; // Fallback für unbekannte Paare
}
   

    const maxLots = (capital * leverage) / basis;
    let output = `💰 <strong>Max. Lotgröße (${pair}):</strong> ${maxLots.toFixed(2)} Lot<br><br>📊 <strong>Stückelung:</strong><br>`;

    const lotSizes = [1.00, 0.80, 0.50, 0.40, 0.20, 0.10, 0.01];
    lotSizes.forEach(size => {
      const times = Math.floor(maxLots / size);
      output += `▸ ${size.toFixed(2)} Lot = ${times > 0 ? times + "x" : "❌ nicht möglich"}<br>`;
    });

    resultEl.innerHTML = output;
    resultEl.style.color = "#0f0";
  }
}






function switchCalcTab(tab) {
  // Alle Rechner ausblenden
  document.querySelectorAll(".calc-box").forEach(box => {
    box.style.display = "none";
  });

  // Den gewünschten Rechner einblenden
  const target = document.getElementById("calc-" + tab);
  if (target) target.style.display = "block";

  // Alle Buttons zurücksetzen
  document.querySelectorAll(".tab-buttons .btn").forEach(btn => btn.classList.remove("active"));

  // Den aktiven Button markieren
  const btn = document.getElementById("btn-calc-" + tab);
  if (btn) btn.classList.add("active");
}



window.addEventListener("DOMContentLoaded", () => {
  initPipPairSelect();
});

</script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
const sessionText = document.getElementById("sessionText");
const sessionProgressEl = document.getElementById("sessionProgressDisplay");
const sessionInfoEl = document.getElementById("sessionInfo");
const sessionDetailsBox = document.getElementById("sessionDetailsBox");
const alertBox = document.getElementById("alertBox");
const progressBar = document.getElementById("progressBar");
const progressContainer = document.querySelector(".progress-container");

sessionText.addEventListener("click", () => {
  sessionDetailsBox.style.display = sessionDetailsBox.style.display === "block" ? "none" : "block";
});

function formatHM(mins) {
  const h = Math.floor(mins / 60) % 24;
  const m = mins % 60;
  return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
}

const sessionColors = {
  Sydney: "#3388ff",
  Tokyo: "#00aaff",
  London: "#ffd700",
  "New York": "#ff4500",
  "London Killzone": "#ccff00",
  "New York Killzone": "#ff8800",
  Deadzone: "#333",
  Crypto: "#9900ff"  // 🔥 Jetzt mit Farbe!
};


const sessions = [
  {
    name: "Sydney",
    start: 1380,
    end: 480,
    info: "Ruhiger Markt, geringere Liquidität, Vorbereitung auf Asien.",
    weekDaysInfo: [
      { day: "Sonntag", text: "🛠️ Vorbereitung auf neue Woche" },
      { day: "Montag", text: "🌏 Asien-Session startet – AUD/USD, NZD/USD im Fokus" },
      { day: "Mittwoch", text: "📊 Wirtschaftsdaten Australien – AUD/CAD, AUD/JPY interessant" },
      { day: "Freitag", text: "📅 Wöchentliche Analyse & Planung – AUD/NZD Moves möglich" }
    ],
  },
  {
    name: "Tokyo",
    start: 60,
    end: 600,
    info: "Moderate Volatilität, Fokus auf JPY/AUD/NZD, Breakouts möglich.",
    weekDaysInfo: [
      { day: "Dienstag", text: "🏦 BoJ Pressekonferenz – EUR/JPY, GBP/JPY sehr aktiv" },
      { day: "Donnerstag", text: "📈 Japan BIP-Daten – USD/JPY, CAD/JPY im Blick behalten" },
      { day: "Freitag", text: "🇺🇸 US NFP wirkt oft nach – Yen-Paare volatil: USD/JPY, GBP/JPY" }
    ],
  },
  {
    name: "London",
    start: 540,
    end: 1020,
    info: "Hohe Liquidität, starke Bewegungen, europäische Wirtschaftsdaten.",
    weekDaysInfo: [
      { day: "Montag", text: "📉 EU Handelsdaten – EUR/USD, EUR/JPY, DAX" },
      { day: "Dienstag", text: "🏛️ Zinsentscheidungen der EZB – EUR/USD, EUR/GBP, EUR/CHF" },
      { day: "Donnerstag", text: "📊 Inflationsdaten UK – GBP/USD, GBP/JPY, FTSE100" },
      { day: "Freitag", text: "📅 Arbeitsmarktdaten UK – GBP/USD, EUR/GBP" }
    ],
  },
  {
    name: "New York",
    start: 870,
    end: 1380,
    info: "Hohe Volatilität, US-Daten dominieren, Trendfortsetzungen möglich.",
    weekDaysInfo: [
      { day: "Mittwoch", text: "🏦 Fed Zinsentscheidungen – USD/JPY, EUR/USD, Gold (XAU/USD)" },
      { day: "Freitag", text: "📊 US NFP Arbeitsmarktdaten – XAU/USD, NAS100, USD/CHF" },
      { day: "Freitag", text: "📈 Wöchentliche Arbeitslosenmeldung – EUR/USD, USD/CAD" }
    ],
  },
  {
    name: "London Killzone",
    start: 420,
    end: 660,
    info: "Volatile Phase vor London-Open, Stop-Hunts möglich.",
    weekDaysInfo: [
      { day: "Montag", text: "⚡ Hohe Volatilität durch Marktöffnung – GBP/USD, EUR/JPY" },
      { day: "Mittwoch", text: "🔥 Breakouts oft möglich – GBP/JPY, DAX, EUR/USD" }
    ],
  },
  {
    name: "New York Killzone",
    start: 810,
    end: 1020,
    info: "Start der NY Session, hohe Aktivität, gute Chancen für Daytrader.",
    weekDaysInfo: [
      { day: "Dienstag", text: "⚡ Erhöhte Volatilität durch US-Daten – XAU/USD, NAS100" },
      { day: "Donnerstag", text: "🎙️ Fed Reden & Daten – USD/JPY, Gold, SPX500" }
    ],
  },
  {
    name: "Deadzone",
    start: 1380,
    end: 0,
    info: "Niedrige Volatilität, Seitwärtsbewegungen, Ruhephase.",
    weekDaysInfo: [
      { day: "Täglich", text: "😴 Markt ruhig, kaum Bewegung – Scalping-Pause empfohlen" }
    ],
  },
  {
    name: "Crypto",
    start: 0,
    end: 1440,
    info: "Krypto läuft 24/7 – Spitzenvolumen oft bei Überschneidung mit NY & Asien.",
    weekDaysInfo: [
      { day: "Montag", text: "🚀 Reaktion auf Wochenstart – Gap-Moves checken – BTC/USD, ETH/USD" },
      { day: "Mittwoch", text: "📉 Midweek-Reversal bei BTC häufig – BTC/USD, SOL/USDT" },
      { day: "Freitag", text: "💸 Ausbruch vor Wochenende, dann Flat Market – ETH/USD, XRP/USD" },
      { day: "Samstag", text: "🧘 Wenig Volumen – Fokus auf Konsolidierungen – BTC, ETH" },
      { day: "Sonntag", text: "⏳ Pre-Move für Montag oft sichtbar – BTC/USD, LINK/USDT" }
    ],
  }
];




let lastAlertSession = null;

function getMinutesNow() {
  const now = new Date();
  return now.getHours() * 60 + now.getMinutes();
}

function getCurrentSessions(minNow) {
  return sessions.filter((s) => {
    const start = s.start;
    const end = s.end;
    if (start > end) {
      return minNow >= start || minNow < end;
    } else {
      return minNow >= start && minNow < end;
    }
  });
}

function updateGradientBar(colors) {
  if (colors.length === 0) {
    progressBar.style.background = "#444";
    progressBar.style.backgroundImage = "";
    return;
  }
  const svg = `
    <svg xmlns='http://www.w3.org/2000/svg' width='100%' height='100%'>
      <defs>
        <linearGradient id='g' x1='0%' y1='0%' x2='100%' y2='0%'>
          ${colors.map((c, i) => `<stop offset='${(i / (colors.length - 1)) * 100}%' stop-color='${c}'/>`).join("")}
        </linearGradient>
      </defs>
      <rect x='0' y='0' width='100%' height='100%' fill='url(#g)'/>
    </svg>`;
  const base64 = btoa(svg);
  progressBar.style.backgroundImage = `url("data:image/svg+xml;base64,${base64}")`;
}

function hexToRgba(hex, alpha) {
  hex = hex.replace("#", "");
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}

function getMinutesToNextSession(minNow) {
  const futureStarts = sessions.map((s) => s.start).filter((start) => start > minNow);
  if (futureStarts.length === 0) return sessions[0].start + 1440 - minNow;
  return Math.min(...futureStarts) - minNow;
}

const alertSound = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg');

function requestNotificationPermission() {
  if ("Notification" in window && Notification.permission !== "granted") {
    Notification.requestPermission().then(permission => {
      console.log("🔐 Notification permission:", permission);
    });
  }
}






function showSessionProgress(activeSessions, currentMinutes) {
  let output = "";

  // 🔸 Aktuelle Session anzeigen
  if (activeSessions.length > 0) {
    const current = activeSessions[0];
    let start = current.start;
    let end = current.end;
    if (start > end) end += 1440;
    let nowMins = currentMinutes;
    if (nowMins < start) nowMins += 1440;
    const duration = end - start;
    const progressMins = nowMins - start;
    const percent = (progressMins / duration) * 100;
    const timeLeft = end - nowMins;

    output += `⏱️ Noch <strong>${formatHM(timeLeft)}</strong> in <strong>${current.name}</strong><br>`;
  } else {
    output += `⏱️ Aktuell <strong>keine Session aktiv</strong><br>`;
  }

  // 🔜 Nächste Session anzeigen
  const futureSessions = sessions
    .map(s => ({
      ...s,
      startMins: s.start > currentMinutes ? s.start : s.start + 1440
    }))
    .sort((a, b) => a.startMins - b.startMins);

  const next = futureSessions[0];
  const minsToNext = next.startMins - currentMinutes;

  output += `🔜 Nächste: <strong>${next.name}</strong> in <strong>${formatHM(minsToNext)}</strong>`;

  // Ausgabe einfügen
  sessionProgressEl.innerHTML = output;
}


function updateRealTimeBar() {
  const now = new Date();
  const weekday = now.getDay(); // Sonntag = 0, Samstag = 6
  const hours = String(now.getHours()).padStart(2, "0");
  const mins = String(now.getMinutes()).padStart(2, "0");
  const minutes = now.getHours() * 60 + now.getMinutes();
  const percent = (minutes / 1439) * 100;

  // Fortschrittsbalken immer aktualisieren
  progressBar.style.width = `${percent}%`;

  // ✅ Definiere echten Krypto-Wochenende-Zeitraum
  const isCryptoWeekend =
    (weekday === 6) || // Samstag
    (weekday === 0) || // Sonntag
    (weekday === 5 && minutes >= 1380); // Freitag ab 23:00

  if (isCryptoWeekend) {
    sessionText.textContent = `🕒 ${hours}:${mins} | Krypto-Wochenende aktiv`;
    sessionInfoEl.innerHTML = `
      📴 Forex & Indizes geschlossen –
      <span class="crypto-animate">
        <span class="coin">🪙</span> Krypto 24/7!
      </span>
    `;
    sessionProgressEl.innerHTML = "🟢 Aktive Crypto-Session – Trade BTC, ETH & Co. jederzeit!";

    let weekendInfo = "";

    if (weekday === 5 && minutes >= 1380) {
      weekendInfo = `
        <strong>🪙 Krypto ist aktiv (24/7)</strong><br>
        📅 <strong>Freitagabend:</strong><br>
        • 🕖 Letzte Volatilität vor dem Wochenschluss (18–22 Uhr)<br>
        • 🔁 Take-Profits & Wochenschluss-Spikes<br>
        • 📉 BTC oft rückläufig durch Positionsschließungen<br>
        • ⚠️ Fakeouts & Liquiditätsgrabs vor der Ruhephase<br><br>
        🚀 Bereite deine Watchlist fürs Wochenende vor!
      `;
    } else if (weekday === 6) {
      weekendInfo = `
        <strong>🪙 Krypto ist aktiv (24/7)</strong><br>
        📅 <strong>Samstag:</strong><br>
        • 😴 Niedriges Volumen – kaum Institutionelle aktiv<br>
        • 🔄 Meist Seitwärtsphasen → ideal für Range-Trading<br>
        • ❄️ Impulsarme Märkte, gute Zeit für technische Analyse<br>
        • 📐 Setups vorbereiten & Trading-Journal pflegen<br><br>
        🧘 Fokus auf Klarheit statt Action – perfekter Analyse-Tag.
      `;
    } else if (weekday === 0) {
      weekendInfo = `
        <strong>🪙 Krypto ist aktiv (24/7)</strong><br>
        📅 <strong>Sonntag:</strong><br>
        • ⏳ Pre-Move-Phase startet oft ab 18–20 Uhr<br>
        • 🧠 Smart Money beginnt Positionierung für Montag<br>
        • 🪤 False Breakouts oder „Liquidity Sweeps“ typisch<br>
        • 🔥 Volumen steigt spürbar, besonders vor News-Wochen<br><br>
        🚀 Nutze den Sonntagabend für Setup-Feintuning & Ausblick!
      `;
    }

    sessionDetailsBox.innerHTML = weekendInfo;
    return; // 👉 Verhindert normale Session-Anzeige
  }


  // ⏬ Werktag-Session-Logik
  const activeSessions = getCurrentSessions(minutes);
  const names = activeSessions
  .map(s => s.name)
  .filter(n => n !== "Crypto"); // 🔥 Crypto wird vom Balken ausgeschlossen

  const activeNames = names.length > 0 ? `| Aktive Session: ${names.join(" + ")}` : "| Keine Session aktiv";
  sessionText.textContent = `🕒 ${hours}:${mins} ${activeNames}`;

  const colors = names.map(n => sessionColors[n] || "#666");
  updateGradientBar(colors);
  showSessionProgress(activeSessions, minutes);

  progressContainer.style.boxShadow = colors.length > 0
    ? `0 0 12px 6px ${hexToRgba(colors[0], 0.6)}`
    : "0 0 12px 6px rgba(0,0,0,0)";

  const name = activeSessions.length > 0 ? activeSessions[0].name : "";
  let infoText = "Keine aktiven Sessions – Markt wahrscheinlich ruhig.";

  if (name === "Tokyo") {
    infoText = minutes < 180 ? "🌏 Tokyo eröffnet – erste Bewegungen durch asiatische Händler." :
                minutes < 360 ? "🇯🇵 Asiatische Volatilität aktiv – mögliche Bewegungen bei JPY." :
                "🛑 Tokyo flacht ab – Fokus wechselt langsam nach Europa.";
  } else if (name === "London Killzone") {
    infoText = "⚠️ London Killzone – hohe Volatilität & starke Bewegungen möglich.";
  } else if (name === "London") {
    infoText = minutes < 720 ? "💷 London Session – Markt in Bewegung, europäische Daten entscheidend." :
                minutes < 840 ? "😴 Mittagliche Deadzone – Markt konsolidiert häufig, Vorsicht bei Entries." :
                "📈 London-Teilnehmer bleiben aktiv – Vorbereitung auf NY.";
  } else if (name === "New York Killzone") {
    infoText = "🔥 New York Killzone – starke Reaktionen auf US-News & Breakouts möglich.";
  } else if (name === "New York") {
    infoText = minutes < 1080 ? "🇺🇸 New York Session – starker US-Einfluss, Trendfortsetzungen möglich." :
                minutes < 1200 ? "📉 New York flacht ab – Markt beruhigt sich langsam." :
                "🌃 New York Session endet – geringe Bewegung, Vorsicht bei Entries.";
  } else if (name === "Crypto") {
    if (weekday === 6) {
      infoText = "🧘 Samstag – ruhige Konsolidierungen, optimal für Range-Trading.";
    } else if (weekday === 0) {
      infoText = minutes < 1080 ? "😴 Sonntagvormittag – flacher Markt, aber Pre-Move kann sich aufbauen." :
                  "⏳ Sonntagabend – mögliche Pre-Moves vor dem Forex-Start.";
    } else if (weekday === 5 && minutes >= 1080) {
      infoText = "💸 Freitagabend – letzte Volatilität, oft BTC-Ausbrüche vor dem Wochenende.";
    } else {
      infoText = "🪙 Krypto läuft 24/7 – typischer Fokus: BTC/ETH & News-getriebene Altcoins.";
    }
  } else if (minutes >= 720 && minutes < 840) {
    infoText = "😴 Mittagliche Deadzone – Markt konsolidiert häufig, Vorsicht bei Entries.";
  } else if (minutes >= 1380 || minutes < 60) {
    infoText = "🌙 Nacht-Deadzone – Markt ist extrem ruhig, keine relevanten Bewegungen.";
  }

  sessionInfoEl.textContent = infoText;

  // 📋 Aktive Session-Details + Wochentagstexte
  if (activeSessions.length > 0) {
    let fullInfo = "";

    activeSessions.forEach(s => {
      let weekDaysHtml = "";
      if (s.weekDaysInfo) {
        weekDaysHtml = "<ul style='margin-left:18px; margin-top:4px;'>";
        s.weekDaysInfo.forEach(({ day, text }) => {
          weekDaysHtml += `<li><strong>${day}:</strong> ${text}</li>`;
        });
        weekDaysHtml += "</ul>";
      }

      const label = s.name.includes("Killzone") ? "🔥" :
                    s.name.includes("New York") ? "🇺🇸" :
                    s.name.includes("London") ? "💷" :
                    s.name.includes("Tokyo") ? "🌏" :
                    s.name.includes("Sydney") ? "🌙" :
                    s.name.includes("Crypto") ? "🪙" : "🟡";

      fullInfo += `
        <strong>${label} ${s.name}</strong><br>
        📅 Start: ${formatHM(s.start)} Uhr<br>
        🕓 Ende: ${formatHM(s.end)} Uhr<br>
        ℹ️ ${s.info}
        ${weekDaysHtml}
        <hr style="border: none; border-top: 1px solid #444; margin: 10px 0;">
      `;
    });

    sessionDetailsBox.innerHTML = fullInfo;
  } else {
    sessionDetailsBox.innerHTML = "Keine aktive Session – Markt ist ruhig.";
  }

  // ⏰ Session-Wechsel-Warnung
  const minutesToNext = getMinutesToNextSession(minutes);
  if (minutesToNext <= 5 && minutesToNext > 0) {
    const currentActive = sessionText.textContent;
    if (lastAlertSession !== currentActive) {
      showAlert(`⚠️ Session-Wechsel in 5 Minuten!`);
      lastAlertSession = currentActive;

      if (activeSessions.length > 0) {
        const s = activeSessions[0];
        showSessionStartNotification(s.name, s.info);
      }
    }
  } else {
    lastAlertSession = null;
  }
}



function updateDaySummary() {
  const days = ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"];
  const infos = {
    "Montag": `
🚀 Start in die Woche – neue Impulse, frische Trends möglich.
🪙 Krypto oft ruhig nach Sonntag – Fokus auf BTC-Reaktion.
    `,
    "Dienstag": `
📈 Trend-Fortsetzung oder technische Korrekturen im Forex.
🪙 BTC & Altcoins reagieren oft auf Marktstimmung.
    `,
    "Mittwoch": `
⚠️ Midweek-Reversal möglich – Vorsicht bei Trendwechseln.
🪙 BTC häufig impulsiv – Fakeouts nicht selten.
    `,
    "Donnerstag": `
📊 News-Donnerstag – viele Wirtschaftsreleases.
🪙 Volatile Altcoins – gute Chancen für Breakouts.
    `,
    "Freitag": `
📅 Wochenabschluss – Gewinne sichern, keine Paniktrades.
🪙 Abends oft BTC-Volatilität vor dem Krypto-Wochenende.
    `,
    "Samstag": `
📴 Forex geschlossen – Markt schläft.
🪙 Nur Krypto aktiv – ideale Zeit für Range-Trading & Analyse.
    `,
    "Sonntag": `
🛠️ Vorbereitung auf neue Woche – Forex inaktiv.
🪙 BTC Pre-Move oft ab 18–20 Uhr – Setup planen!
    `
  };


  const now = new Date();
  const dayIndex = now.getDay();
  const dayName = days[dayIndex];
  const info = infos[dayName] || "📆 Trading-Tag";

  const el = document.getElementById("daySummary");
  el.textContent = `🗓️ ${dayName} – ${info}`;
}

document.addEventListener("DOMContentLoaded", () => {
  const daySummaryEl = document.getElementById("daySummary");
  const dayDetailsEl = document.getElementById("dayDetails");
const dayDetailsMap = {
  "Montag": `
🔵 <strong>Montag</strong><br><br>
<strong>📌 Setup:</strong><br>
Wochenstart – noch keine klare Richtung. Fokus auf erste Liquiditätsreaktionen.<br><br>

<strong>✅ Strategie:</strong><br>
Vorsichtiger Einstieg nach London-Open (09:00–10:00 Uhr)<br><br>

<strong>🕓 Marktverhalten:</strong><br>
Volumen steigt langsam an – viele Trader warten auf Dienstag.<br><br>

<strong>📊 Wirtschaftsdaten:</strong><br>
<ul>
  <li>🇪🇺 EU-Handelsdaten, Sentiment-Indikatoren</li>
  <li>💬 Kaum US-Daten – NY-Session eher träge</li>
</ul><br>

<strong>🧠 Mentaler Fokus:</strong><br>
Geduldig bleiben – erste Impulse beobachten.<br><br>

<strong>🧾 To-do am Montag:</strong><br>
<ul>
  <li>📅 Wochenziele notieren</li>
  <li>📈 H1/H4 Bias eintragen</li>
</ul><br>

<strong>🪙 Krypto-Notiz:</strong><br>
BTC reagiert oft träge nach dem Wochenende – Strukturaufbau bis Montagabend.<br>
ETH/BTC-Paare zeigen erste Signale für Volatilität der Woche.
`,

  "Dienstag": `
🟢 <strong>Dienstag</strong><br><br>
<strong>📌 Setup:</strong><br>
Intraday-Trading meist am klarsten – oft Trendfortsetzung oder Retest.<br><br>

<strong>✅ Strategie:</strong><br>
Nutze saubere Marktstruktur → Breakouts + Retest möglich.<br><br>

<strong>🕓 Marktverhalten:</strong><br>
Konstant – London & NY liefern gute Bewegungen.<br><br>

<strong>📊 Wirtschaftsdaten:</strong><br>
<ul>
  <li>🇪🇺 EZB oder UK Reden möglich</li>
  <li>🇺🇸 US-Einstiegsdaten</li>
</ul><br>

<strong>🧠 Mentaler Fokus:</strong><br>
Keine Hektik – Struktur traden.<br><br>

<strong>🧾 To-do am Dienstag:</strong><br>
<ul>
  <li>⚙️ Trade-Log abgleichen</li>
  <li>📓 Swing-Kandidaten markieren</li>
</ul><br>

<strong>🪙 Krypto-Notiz:</strong><br>
BTC/ETH ziehen meist am Dienstag an – viele Altcoins folgen.<br>
Guter Tag für FVG/Breaker-Entry in Krypto.
`,

  "Mittwoch": `
🟡 <strong>Mittwoch</strong><br><br>
<strong>📌 Setup:</strong><br>
Midweek-Reversal – viele Fehlausbrüche möglich.<br><br>

<strong>✅ Strategie:</strong><br>
Reversal-Potenziale beachten, Killzones gezielt handeln.<br><br>

<strong>🕓 Marktverhalten:</strong><br>
Volatilität steigt – Intraday-Highs/Lows werden geholt.<br><br>

<strong>📊 Wirtschaftsdaten:</strong><br>
<ul>
  <li>🏦 FOMC/Fed Minutes</li>
  <li>🇪🇺 EU/UK Inflationsdaten</li>
</ul><br>

<strong>🧠 Mentaler Fokus:</strong><br>
Flexibel bleiben – Bias kann kippen.<br><br>

<strong>🧾 To-do am Mittwoch:</strong><br>
<ul>
  <li>📈 Midweek-Revue</li>
</ul><br>

<strong>🪙 Krypto-Notiz:</strong><br>
BTC macht oft genau am Mittwoch seine Wochenrichtung klar oder Fake-Move – Fokus auf Liquiditätszonen.
`,

  "Donnerstag": `
🟠 <strong>Donnerstag</strong><br><br>
<strong>📌 Setup:</strong><br>
Momentum-Tag – viele Impulse durch News.<br><br>

<strong>✅ Strategie:</strong><br>
NY-Killzone aktiv handeln – Fokus auf USD, Gold, NAS100.<br><br>

<strong>🕓 Marktverhalten:</strong><br>
London & NY klar – guter Trend-Tag.<br><br>

<strong>📊 Wirtschaftsdaten:</strong><br>
<ul>
  <li>🇺🇸 GDP, PCE, CPI</li>
</ul><br>

<strong>🧠 Mentaler Fokus:</strong><br>
Mutig, aber sauber – Reaktionen abwarten.<br><br>

<strong>🧾 To-do am Donnerstag:</strong><br>
<ul>
  <li>🧠 Gewinne sichern</li>
</ul><br>

<strong>🪙 Krypto-Notiz:</strong><br>
Donnerstag ist oft der „Catch-up-Tag“ für Altcoins – hohe Dynamik bei Krypto-Volumen im NY-Overlap.
`,

  "Freitag": `
🔴 <strong>Freitag</strong><br><br>
<strong>📌 Setup:</strong><br>
Scalping & Intraday – große Bewegungen meist vorbei.<br><br>

<strong>✅ Strategie:</strong><br>
Nur Liquiditätsjagden handeln – keine blind Breakouts.<br><br>

<strong>🕓 Marktverhalten:</strong><br>
Ruhiger ab 13:00 Uhr – Positionsschließung dominiert.<br><br>

<strong>📊 Wirtschaftsdaten:</strong><br>
<ul>
  <li>📈 US-Arbeitsmarktdaten (oft 14:30 Uhr)</li>
</ul><br>

<strong>🧠 Mentaler Fokus:</strong><br>
Kein FOMO, kein Revenge-Trading.<br><br>

<strong>🧾 To-do am Freitag:</strong><br>
<ul>
  <li>📊 Wochenstatistik eintragen</li>
</ul><br>

<strong>🪙 Krypto-Notiz:</strong><br>
Ab 18:00 Uhr: BTC beginnt Pre-Move für Wochenende.<br>
BTC/ETH brechen oft vor dem „Krypto-Samstag“ aus – Watchlist ready machen.
`,

  "Samstag": `
📴 <strong>Samstag</strong><br><br>
Kein Handel in Forex – aber Krypto läuft.<br><br>

<strong>🪙 Krypto-Notiz:</strong><br>
• Wenig Volumen – ideal für Struktur-Analyse<br>
• Range-Trading auf BTC/ETH sehr effektiv<br>
• Vorbereitung auf Sonntag → Pre-Move beachten
`,

  "Sonntag": `
📴 <strong>Sonntag</strong><br><br>
Noch kein Handel in Forex – aber wichtigster Vorbereitungstag.<br><br>

<strong>🪙 Krypto-Notiz:</strong><br>
• Ab 18:00 Uhr: BTC/ETH zeigen oft erste Richtung<br>
• Pre-Move für die Woche sichtbar<br>
• Setups validieren & Einstiegslevel berechnen
`
};


  if (daySummaryEl && dayDetailsEl) {
    daySummaryEl.addEventListener("click", () => {
      const now = new Date();
      const dayName = ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"][now.getDay()];
      const content = dayDetailsMap[dayName] || "📆 Keine Details für diesen Tag.";

      const visible = dayDetailsEl.style.display === "block";
      dayDetailsEl.style.display = visible ? "none" : "block";
      if (!visible) dayDetailsEl.innerHTML = content;
    });
  }

  updateDaySummary();
});




window.addEventListener("load", () => {
  requestNotificationPermission();
  updateRealTimeBar();
  updateDaySummary(); // 📅 Wochentag-Anzeige aktualisieren

  setInterval(updateRealTimeBar, 60000);
});
</script>



<script>
// ✅ Service Worker Registrierung
if ("serviceWorker" in navigator) {
  window.addEventListener("load", () => {
    navigator.serviceWorker
      .register("sw.js")
      .then(reg => console.log("✅ Service Worker registriert:", reg))
      .catch(err => console.error("❌ SW Registrierung fehlgeschlagen:", err));
  });
}

// ✅ App-Install Trigger mit Button
let deferredPrompt = null;

window.addEventListener('beforeinstallprompt', (e) => {
  console.log("🟡 beforeinstallprompt ausgelöst");
  e.preventDefault();
  deferredPrompt = e;
  showInstallButton();
});

function showInstallButton() {
  if (localStorage.getItem("installPromptHandled") === "true") return;
  if (document.getElementById("installBtn")) return;

  const installBtn = document.createElement("button");
  installBtn.id = "installBtn";
  installBtn.textContent = "📲 App installieren";
  installBtn.className = "big-btn";
  installBtn.style.position = "fixed";
  installBtn.style.bottom = "80px";
  installBtn.style.left = "50%";
  installBtn.style.transform = "translateX(-50%)";
  installBtn.style.zIndex = "9999";
  document.body.appendChild(installBtn);

  installBtn.addEventListener("click", () => {
    installBtn.remove();
    localStorage.setItem("installPromptHandled", "true"); // ✅ Nur einmal fragen
    if (deferredPrompt) {
      deferredPrompt.prompt();
      deferredPrompt.userChoice.then((choiceResult) => {
        console.log("📥 Installationswahl:", choiceResult.outcome);
        deferredPrompt = null;
      });
    }
  });
}

// 🕒 Fallback-Check nach 3 Sekunden, ob der Button angezeigt werden kann
setTimeout(() => {
  if (deferredPrompt) {
    showInstallButton();
  } else {
    console.log("❌ Kein Install-Event verfügbar");
  }
}, 3000);
</script>

<script>
function sendPushNotification(title, message) {
  if ("Notification" in window && Notification.permission === "granted" && "serviceWorker" in navigator) {
    navigator.serviceWorker.ready.then((registration) => {
      registration.showNotification(title, {
        body: message,
        icon: "https://cdn-icons-png.flaticon.com/512/1827/1827409.png",
        vibrate: [200, 100, 200],
        tag: "session-alert",
        renotify: true
      });
    }).catch(err => {
      console.error("❌ Notification via Service Worker fehlgeschlagen:", err);
    });
  } else {
    console.warn("❌ Keine Notification möglich – Erlaubnis oder SW fehlen.");
  }
}

// ✅ Einheitlicher Notification-Aufruf für Sessionstarts
function showSessionStartNotification(sessionName, message) {
  const title = `📣 ${sessionName}-Session gestartet!`;
  sendPushNotification(title, message);
}

// ✅ Diagnosetool zum Testen
function diagnoseNotifications() {
  const output = document.getElementById("notificationStatus");
  output.style.display = "block";

  let msg = "🔍 <strong>Benachrichtigungs-Check:</strong><br>";

  if (!("Notification" in window)) {
    msg += "❌ Notifications werden vom Browser nicht unterstützt.<br>";
  } else {
    msg += `📱 Notification.permission: <strong>${Notification.permission}</strong><br>`;
    if (Notification.permission === "granted") {
      try {
        sendPushNotification("✅ Test-Notification", "🎯 Die Notification funktioniert!");
        msg += "✅ Test-Notification wurde ausgelöst.<br>";
      } catch (err) {
        msg += "❌ Fehler beim Notification-Aufruf: " + err.message + "<br>";
      }
    } else if (Notification.permission === "denied") {
      msg += "🚫 Du hast Benachrichtigungen blockiert.<br>";
    } else if (Notification.permission === "default") {
      Notification.requestPermission().then((perm) => {
        msg += `📩 Neue Erlaubnis: ${perm}<br>`;
      });
    }
  }

  output.innerHTML = msg;
}

// ✅ Aktivierungs-Button
function enableNotifications() {
  Notification.requestPermission().then(permission => {
    const statusBox = document.getElementById("notificationStatus");
    statusBox.style.display = "block";

    if (permission === "granted") {
      sendPushNotification("✅ Erlaubt", "Du bekommst ab jetzt Benachrichtigungen!");
      statusBox.innerHTML = "✅ Benachrichtigungen erlaubt!";
    } else if (permission === "denied") {
      statusBox.innerHTML = "❌ Benachrichtigungen blockiert. Aktiviere sie im Schloss-Symbol der Adresszeile.";
    } else {
      statusBox.innerHTML = "ℹ️ Keine Entscheidung getroffen.";
    }
  });
}
</script>
<script>
function saveJournalEntryWithImages(imageIds) {
  const entries = JSON.parse(localStorage.getItem("journalData") || []);

  const newEntry = {
    id: Date.now(),
    date: new Date().toISOString().slice(0, 10),
    comment: document.getElementById("journalComment")?.value || "",
    result: document.getElementById("resultSelect")?.value || "neutral",
    images: {
      before: imageIds,
      after: [] // vorerst leer
    }
  };

  entries.push(newEntry);
  localStorage.setItem("journalData", JSON.stringify(entries));
  alert("✅ Journal gespeichert mit Bildern!");
  buildJournalCalendar(); // ⬅️ Kalender aktualisieren
}


document.getElementById("screenshotInput").addEventListener("change", function (event) {
  const previewBox = document.getElementById("imagePreviewBox");
  if (!previewBox) return;

  previewBox.innerHTML = ""; // leeren
  Array.from(event.target.files).forEach(file => {
    const reader = new FileReader();
    reader.onload = function (e) {
      const img = document.createElement("img");
      img.src = e.target.result;
      img.style.maxWidth = "100px";
      img.style.margin = "5px";
      img.style.borderRadius = "6px";
      previewBox.appendChild(img);
    };
    reader.readAsDataURL(file);
  });
});


function showLightbox(src) {
  const overlay = document.getElementById("lightboxOverlay");
  const image = document.getElementById("lightboxImage");
  image.src = src;
  overlay.style.display = "flex";
}

function closeLightbox() {
  document.getElementById("lightboxOverlay").style.display = "none";
}
function saveImageToIndexedDB(base64, id) {
  const request = indexedDB.open("TradeAppDB", 1);
  request.onupgradeneeded = function(event) {
    const db = event.target.result;
    if (!db.objectStoreNames.contains("images")) {
      db.createObjectStore("images", { keyPath: "id" });
    }
  };
  request.onsuccess = function(event) {
    const db = event.target.result;
    const tx = db.transaction("images", "readwrite");
    const store = tx.objectStore("images");
    store.put({ id, image: base64 });
  };
}

</script>


<body>


<script src="imageStorage.js"></script>

</body>
</html>
